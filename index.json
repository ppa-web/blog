[{"categories":["Tools"],"contents":" ","permalink":"https://codingactions.com/tools/multi-screen-test/","tags":["Multi Screen Resolution Test"],"title":"Multi Screen Resolution Test"},{"categories":["Coding"],"contents":" How to get My Public IP address Using Python In this tutorial, we will learn About External Public IP address:\nWhat is Public IP address A public IP address is a globally unique IP address that is assigned to a device connected to the internet. It is used to identify and locate devices on the internet, and it allows devices to communicate with each other over the internet.\nPublic IP addresses are assigned by Internet Service Providers (ISPs) to devices that are connected to the internet through them. The devices can be computers, servers, routers, or any other device that is connected to the internet.\nThere are two types of public IP addresses: IPv4 and IPv6. IPv4 addresses are 32-bit numbers that are written in a dot-decimal notation, such as 192.168.0.1. IPv6 addresses are 128-bit numbers that are written in a hexadecimal notation, such as 2001:0db8:85a5:0000:0000:8a2e:0370:6334.\nHow to get My Public IP address Using Python In this digital age, knowing your public IP address is essential for various networking and programming tasks. Python, being a versatile and powerful programming language, provides several methods to retrieve this information. In this article, we will explore different approaches to obtain your public IP address using Python.\nMethod 1: Using an External Service (Using Requests Library) One of the simplest ways to retrieve your public IP address is by utilizing external services that provide this information. The requests library in Python makes it easy to fetch data from such services. Here\u0026rsquo;s an example:\nimport requests def get_public_ip(): response = requests.get('https://api.ipify.org') return response.text public_ip = get_public_ip() print(\u0026quot;Your public IP address is:\u0026quot;, public_ip) Sample output:\nOutput: Your public IP address is: 30.5.3.34 In the code above, we use the requests.get() method to send a GET request to the IPify API ( https://www.ipify.org/) . The API responds with your public IP address, which we extract using response.text.\nMethod 2: Utilizing a DNS Service (Using dnspython Library) Another approach to obtaining your public IP address involves querying a DNS (Domain Name System) service. The dnspython library in Python allows us to perform DNS-related tasks conveniently. Here\u0026rsquo;s an example:\nimport dns.resolver def get_public_ip(): resolver = dns.resolver.Resolver() resolver.nameservers = ['8.8.8.8'] # Use Google Public DNS server response = resolver.query('myip.opendns.com', 'A') return response[0].address public_ip = get_public_ip() print(\u0026quot;Your public IP address is:\u0026quot;, public_ip) In the code above, we create a resolver object and set the nameservers to use Google\u0026rsquo;s Public DNS server (8.8.8.8). We then query the DNS record myip.opendns.com of type \u0026lsquo;A\u0026rsquo; to retrieve the IP address associated with it.\nMethod 3: Parsing IP from a Website (Using Beautiful Soup) Sometimes, websites include your IP address in their HTML content. We can leverage web scraping techniques using the beautifulsoup4 library to extract this information. Here\u0026rsquo;s an example:\nimport requests from bs4 import BeautifulSoup def get_public_ip(): response = requests.get('https://www.whatismyip.com/') soup = BeautifulSoup(response.text, 'html.parser') ip_element = soup.find('span', class_='green_ip') return ip_element.text public_ip = get_public_ip() print(\u0026quot;Your public IP address is:\u0026quot;, public_ip) In the code above, we send a GET request to \u0026lsquo; https://www.whatismyip.com/' and parse the HTML content using Beautiful Soup. We locate the HTML element with the class \u0026lsquo;green_ip\u0026rsquo;, which typically contains the public IP address, and extract its text.\nAlternative servers If you encounter a problem with the external website server, you can use one of the alternative servers listed below.\nhttps://api.ipify.org https://tnx.nl/ip https://api.infoip.io/ip Free Online IPV4 and IPV6 tool You can also use our WhatIsMyIp free online to get your IP address!\n","permalink":"https://codingactions.com/how-to-get-my-public-ip-address-using-python/","tags":["Python"],"title":"How to get My Public IP address Using Python"},{"categories":["Automated Testing"],"contents":" Chat GPT for Automated Testing Introduction: In the realm of automated testing, incorporating advanced technologies like Chat GPT can revolutionize the efficiency and effectiveness of the testing process.\nWith its language generation capabilities and natural language understanding, Chat GPT can bring new dimensions to automated testing, complementing existing tools like Cypress and Selenium. In this article, we will delve deeper into how Chat GPT can be integrated with popular testing frameworks and provide real-life examples to demonstrate its practical applications.\nTest Case Generation: Chat GPT can play a vital role in generating comprehensive and diverse test cases for automated testing. When integrated with testing frameworks like Cypress or Selenium, Chat GPT can be used to create test scripts by leveraging its language generation capabilities. For example, Chat GPT can generate test cases that cover various user flows, input combinations, and edge cases. These generated test cases can then be executed using Cypress or Selenium to validate the application\u0026rsquo;s behavior.\nUser Interaction Simulation: Simulating user interactions is a fundamental aspect of testing. By integrating Chat GPT with tools like Cypress or Selenium, it becomes possible to simulate user interactions through conversational scripts. For example, in an e-commerce application, Chat GPT can generate conversational scripts representing different user scenarios such as login, product search, cart management, and checkout. These scripts can then be executed using Cypress or Selenium to validate the application\u0026rsquo;s behavior, ensuring a thorough testing process.\nNatural Language Test Oracles: Validating the correctness of application behavior is crucial in automated testing. Chat GPT can be employed to create natural language test oracles, which act as evaluation criteria for automated tests. By training Chat GPT on the expected behavior of the system, it can provide human-like judgments on whether the system under test produces the correct responses. This allows for more intuitive and readable verification of application functionality, enhancing the accuracy of automated tests.\nDynamic Test Data Generation: Generating dynamic and realistic test data is crucial for comprehensive testing. Chat GPT can assist in generating synthetic test data that closely resembles real-world scenarios. By leveraging its language generation capabilities, Chat GPT can create realistic data for testing purposes. For instance, in a social media application, Chat GPT can generate user profiles with various demographics, interests, and relationship statuses. This synthetic test data can be utilized with tools like Cypress or Selenium to validate the application\u0026rsquo;s handling of diverse scenarios.\nReal-Life Examples: E-commerce Application Testing with Cypress: Chat GPT can generate Cypress test scripts that cover various user journeys such as registration, product search, adding items to the cart, and checkout. By incorporating Chat GPT-generated scripts into Cypress, the application\u0026rsquo;s functionality can be thoroughly tested, including scenarios like discounts, payment failures, and order tracking.\nWeb Application Testing with Selenium: By integrating Chat GPT with Selenium, realistic test data can be generated to simulate user profiles, user-generated content, or form submissions.\nThis allows for comprehensive testing of web applications, including scenarios like user authentication, data validation, and error handling.\nVoice Assistant Testing with Cypress and Selenium: Testing voice assistant applications requires extensive coverage of voice commands and responses. Chat GPT can generate conversational scripts that simulate various voice inputs, and these scripts can be executed using Cypress or Selenium. This integration ensures accurate testing of the voice assistant\u0026rsquo;s functionality, including scenarios like voice recognition accuracy, context-aware responses, and handling of ambiguous queries.\nConclusion: Chat GPT, when integrated with popular testing frameworks like Cypress and Selenium, offers a powerful approach to enhance automated testing. Its capabilities in test case generation, natural language test oracles, user interaction simulation, and dynamic test data generation enable a comprehensive and efficient testing process. By leveraging Chat GPT alongside existing testing tools\n","permalink":"https://codingactions.com/automated-testing/automated-testing-with-chat-gpt/","tags":["Chat GPT","Automated Testing"],"title":"Automated Testing with Chat GPT"},{"categories":["DevOps"],"contents":"The importance of Docker Environment Variables Understanding the Significance of Docker Environment Variables\nDocker Environment variables play a pivotal role in Docker and Docker Compose. By delving into this topic, you\u0026rsquo;ll gain valuable insights into configuring your Docker images and dockerized applications effortlessly. Harnessing the potential of Docker build-time variables, environment variables, and docker-compose templating, you can streamline the process effectively.\nThis article will help you to understand the Docker Environment Variable and you will able to work with Docker ENV, ARG, env_file and .env files with confidence.\nBy the end of this article, you will be able to confidently answer these kinds of questions:\nWhat are environment variables in Docker? How do I pass environment variables to Docker containers? What is difference between env and Arg in docker? Common Misconceptions About Docker Environment Variables Here\u0026rsquo;s a list of easy takeaways:\nCommon Misconceptions About Docker Environment Variables The .env file, is only used during a pre-processing step when working with docker-compose.yml files. Dollar-notation variables like $HI are substituted for values contained in an \u0026ldquo;.env\u0026rdquo; named file in the same directory. ARG is only available during the build of a Docker image (RUN etc), not after the image is created and containers are started from it (ENTRYPOINT, CMD). You can use ARG values to set ENV values to work around that. ENV values are available to containers, but also RUN-style commands during the Docker build starting with the line where they are introduced. If you set an environment variable in an intermediate container using bash (RUN export VARI=6 \u0026amp;\u0026amp; …) it will not persist in the next command. There\u0026rsquo;s a way to work around that. An env_file, is a convenient way to pass many environment variables to a single command in one batch. This should not be confused with a .env file. Setting ARG and ENV values leaves traces in the Docker image. Don\u0026rsquo;t use them for secrets which are not meant to stick around (well, you kinda can with multi-stage builds). Docker env Key Concepts The complete guide is split up into the following concepts:\nThe Dot-Env File (.env) ARG and ENV Availability Setting ARG Values Setting ENV Values Overriding ENV Values Feel free to jump right to the one you need. However, you\u0026rsquo;ll get the best result if you read through them all thoroughly.\nThe Dot-Env File (.env) This one is quite simple, and only confusing because of bad examples and similar concepts using the same format, sounding a lot like it. What\u0026rsquo;s important is the dot in front of env - .env, not an \u0026ldquo;env_file\u0026rdquo;.\nIf you have a file named .env in your project, it\u0026rsquo;s only used to put values into the docker-compose.yml file which is in the same folder. Those are used with Docker Compose and Docker Stack. It has nothing to do with ENV, ARG, or anything Docker-specific explained above. It\u0026rsquo;s exclusively a docker-compose.yml thing.\nThe values in the .env file are written in the following notation:\nVARIABLE_NAME=some value OTHER_VARIABLE_NAME=some other value, like 6 Those key-value pairs, are used to substitute dollar-notation variables in the docker-compose.yml file. It\u0026rsquo;s kind of a pre-processing step, and the resulting temporary file is used. This is a nice way to avoid hard-coding values. You can also use this to set the values for environment variables, by substituting the string, but that does not happen automatically.\nHere is an example docker-compose.yml file, relying on values provided from a .env file:\nversion: '3' services: plex: image: circleci/node environment: - env_var_name=${VARIABLE_NAME} # here it is Hint: When working with an .env file, you can debug your docker-compose.yml files quite easily. Just type docker-compose config. This way you’ll see how the docker-compose.yml file content looks after the substitution step has been performed without running anything else.\nARG and ENV Availability When using Docker, we distinguish between two different types of variables - ARG and ENV.\nARG are also known as build-time variables. They are only available from the moment they are \u0026lsquo;announced\u0026rsquo; in the Dockerfile with an ARG instruction up to the moment when the image is built. Running containers can\u0026rsquo;t access values of ARG variables. This also applies to CMD and ENTRYPOINT instructions which just tell what the container should run by default. If you tell a Dockerfile to expect various ARG variables (without a default value) but none are provided when running the build command, there will be an error message.\nHowever, ARG values can be easily inspected after an image is built, by viewing the docker history of an image. Thus they are a poor choice for sensitive data.\nENV variables are also available during the build, as soon as you introduce them with an ENV instruction. However, unlike ARG, they are also accessible by containers started from the final image. ENV values can be overridden when starting a container, more on that below.\nHere is a simplified overview of ARG and ENV availabilities around the process around building a Docker image from a Dockerfile, and running a container. They overlap, but ARG is not usable from inside the containers.\nAn overview of ARG and ENV availability. Setting ARG Values So, you have your Dockerfile, which defines ARG and ENV values. How to set them, and where? You can leave them blank in the Dockerfile, or set default values. If you don\u0026rsquo;t provide a value to expected ARG variables which don\u0026rsquo;t have a default, you\u0026rsquo;ll get an error message.\nHere is a Dockerfile example, both for default values and without them:\nARG some_variable_name # or with a hard-coded default: #ARG some_variable_name=default_value RUN echo \u0026quot;Oh dang look at that $some_variable_name\u0026quot; # you could also use braces - ${some_variable_name} When building a Docker image from the commandline, you can set ARG values using –build-arg:\n$ docker build --build-arg some_variable_name=a_value Running that command, with the above Dockerfile, will result in the following line being printed (among others):\nOutput: Oh dang look at that a_value So, how does this translate to using docker-compose.yml files? When using docker-compose, you can specify values to pass on for ARG, in an args block:\n(docker-compose.yml file)\nversion: \u0026quot;3\u0026quot; services: somename: build: context: ./app dockerfile: Dockerfile args: some_variable_name: a_value When you try to set a variable which is not ARG mentioned in the Dockerfile, Docker will complain.\nSetting ENV Values So, how to set ENV values? You can do it when starting your containers (and we\u0026rsquo;ll look at this a bit below), but you can also provide default ENV values directly in your Dockerfile by hard-coding them. Also, you can set dynamic default values for environment variables!\nWhen building an image, the only thing you can provide are ARG values, as described above. You can\u0026rsquo;t provide values for ENV variables directly. However, both ARG and ENV can work together. You can use ARG to set the default values of ENV vars. Here is a basic Dockerfile, using hard-coded default values:\n# no default value ENV hey # a default value ENV foo /bar # or ENV foo=/bar # ENV values can be used during the build ADD . $foo # or ADD . ${foo} # translates to: ADD . /bar And here is a snippet for a Dockerfile, using dynamic on-build env values:\n# expect a build-time variable ARG A_VARIABLE # use the value to set the ENV var default ENV an_env_var=$A_VARIABLE # if not overridden, that value of an_env_var will be available to your containers! Once the image is built, you can launch containers and provide values for ENV variables in three different ways, either from the command line or using a docker-compose.yml file. All of those will override any default ENV values in the Dockerfile. Unlike ARG, you can pass all kinds of environment variables to the container. Even ones not explicitly defined in the Dockerfile. It depends on your application whether that\u0026rsquo;ll do anything however.\nProvide values one by one\nFrom the commandline, use the -e flag: $ docker run -e \u0026quot;env_var_name=another_value\u0026quot; alpine env From a docker-compose.yml file:\nversion: '3' services: plex: image: circleci/node environment: - env_var_name=another_value Pass environment variable values from your host It\u0026rsquo;s the same as the above method. The only difference is, you don’t provide a value, but just name the variable. This will make Docker access the current value in the host environment and pass it on to the container.\n$ docker run -e env_var_name alpine env For the docker-compose.yml file, leave out the equation sign and everything after it for the same effect.\nversion: '3' services: plex: image: circleci/node environment: - env_var_name Take values from a file (env_file) Instead of writing the variables out or hard-coding them (not in good taste according to the 12-factor folks ), we can specify a file to read values from. The contents of such a file look something like this:\nenv_var_name=another_value The file above is called env_file_name (name arbitrary) and it\u0026rsquo;s located in the current directory. You can reference the filename, which is parsed to extract the environment variables to set:\n$ docker run --env-file=env_file_name alpine env With docker-compose.yml files, we just reference a env_file, and Docker parses it for the variables to set.\nversion: \u0026quot;3\u0026quot; services: plex: image: linuxserver/plex env_file: env_file_name Here is a small cheat sheet, combining an overview of ARG and ENV availability with common ways to set them from the command line.\nAn overview of ARG and ENV availability. Before we move on: a frequent gotcha, if you\u0026rsquo;re new to Docker and not used to think about images and containers: if you try to set the value of an environment variable from inside a RUN statement like RUN export VARI=6 \u0026amp;\u0026amp; ..., you won\u0026rsquo;t have access to it in any of the next RUN statements. The reason for this, is that for each RUN statement, a new container is launched from an intermediate image. An image is saved by the end of the command, but environment variables do not persist that way.\nIf you\u0026rsquo;re curious about an image, and would like to know if it provides default ENV variable values before the container is started, you can inspect images, and see which ENV entries are set by default:\n# first, get the images on your system and their ids $ docker images # use one of those ids to take a closer look $ docker inspect image-id # look out for the \u0026quot;Env\u0026quot; entries Phew, that was quite a bit. The only thing left is - if you have so many different ways of setting the values of ENV variables, which ones override others?\nOverriding ENV Values Assuming, you have an image built from a Dockerfile, which provides default ENV values. Containers started from it, have access to ENV variables defined in the Dockerfile. However, those values can be overridden by providing single environment variables, or env_files, from which environment variables are parsed and passed into the container.\nOnce a process runs inside the container, or when a command is evaluated, they can change the environment values for themselves. Stuff like:\n$docker run myimage SOME_VAR=hi node app.js will completely override any SOME_VAR you might have set otherwise for the app.js script, even if there were some value with a -e flag before the final command.\nThe precedence is, from stronger to less-strong: stuff the containerized application sets, values from single environment entries, values from the env_file(s) and finally Dockerfile defaults.\nDocker Environment Variables Summary I hope you enjoyed this article about the docker environment variables and all the ways you can set ARG and ENV variables when building Docker images and starting containers.\nBy now, you should have a really good overview build-time arguments, environment variables, env_files and docker-compose templating with .env files. I hope you got a lot of value out of it, and can use the knowledge to save yourself lots of bugs in the future.\nTo really master these concepts, just reading about them is not enough. You have to see them in action and apply them to your own work to truly make them part of your tool belt. The best way to make sure you will be able to make use of this information, is to learn by doing – go ahead and try some of those techniques in your current projects!\n","permalink":"https://codingactions.com/understanding-docker-environment-variables/","tags":["Containerization","Docker"],"title":"Docker Environment Variables Explained"},{"categories":["Automated Testing"],"contents":" Chat GPT for Automated Testing Practice automation websites In our journey of learning automated tests, it is crucial to have a dedicated system and application for practicing automation without affecting production systems. In this article, I will present a curated list of the top four websites that can be utilized for practicing automated tests without any impact on live production systems. These platforms are specifically designed to facilitate learning and provide a safe environment for practicing and honing your automation skills.\nLet\u0026rsquo;s explore these websites and discover how they can enhance your learning and practice experience.\nhttps://practice.expandtesting.com/ Practice automation website with demos and examples for UI and API testing using Cypress, Playwright, Selenium, WebdriverIO, Puppeteer, and Postman.\nNice UI Web examples React APP Swagger UI REST API TOOLS (Css, xpath, mocha, chai and JavaScript) https://www.saucedemo.com/ Swag Labs simple react app from sauce labs\ncypress-realworld-app A payment application to demonstrate real-world usage of Cypress testing methods, patterns, and workflows.\nSwag Labs simple react app from sauce labs\n","permalink":"https://codingactions.com/automated-testing/best-practice-automation-websites/","tags":["Chat GPT","Automated Testing"],"title":"Best practice automation websites"},{"categories":["Coding","Tools"],"contents":" The Must-have VS Code Extension for Node.js Developer VS Code extensions Visual Studio Code (VS Code) is a popular source code editor developed by Microsoft. It is free and open-source, and is available for Windows, macOS, and Linux.\nVS Code extensions are packages that add features and functionality to the editor. They can be developed by anyone and are easy to install and use. There are a wide variety of extensions available, ranging from language support and code formatting to debugging and testing tools.\nInstalling extensions in VS Code is simple: you can browse the VS Code Marketplace ( https://marketplace.visualstudio.com/ ) to find the extensions you need, and then use the VS Code extension manager to install them. Once installed, you can enable or disable extensions as needed and configure their settings to suit your needs.\nUsing extensions can greatly enhance your productivity and workflow as a developer, and there are many high-quality extensions available for VS Code.\n20 must-have VS Code extensions for Node.js developers Here is a list of 20 must-have Visual Studio Code (VS Code) extensions for Node.js developers:\nDebugger for Chrome: allows you to debug JavaScript code running in Google Chrome directly from VS Code. Node.js Extension Pack: includes a number of extensions that are useful for Node.js development, including the JavaScript (ES6) code snippets, npm, and Visual Studio IntelliCode. npm: provides autocompletion for npm commands and makes it easy to run npm scripts. JavaScript (ES6) code snippets: provides code snippets for common JavaScript patterns. Jest: provides support for running and debugging Jest test cases. Prettier - Code formatter: automatically formats your code according to a set of rules, helping you avoid style debates with your team. Live Server: allows you to easily launch a development server with live reload support. Path IntelliSense: autocompletes filenames in your code. Docker: provides syntax highlighting, hover tips, and command-line integration for Dockerfile and docker-compose files. GitLens: adds powerful git visualization and exploration tools to VS Code. Git Graph: adds a visual Git history graph to VS Code. ESLint: lints your JavaScript code and helps you fix style issues. TSLint: lints your TypeScript code and helps you fix style issues. npm IntelliSense: provides autocompletion for npm modules in your code. Import Cost: displays the size of imported packages in your code. IntelliJ IDEA Keybindings: adds the keybindings from JetBrains\u0026rsquo; IntelliJ IDEA to VS Code. Bracket Pair Colorizer: adds colors to matching brackets, making it easier to spot matching pairs. Indent Rainbow: adds colors to indentation levels, making it easier to see how code is nested. vscode-icons: adds file icons to VS Code, making it easier to recognize different file types. Quokka.js: a live scratchpad for JavaScript that shows you the results of your code as you type. These extensions can help you improve your productivity and enhance your workflow as a Node.js developer.\n","permalink":"https://codingactions.com/must-have-vs-code-extension-nodejs-developer/","tags":["Nodejs","VsCode","Extension"],"title":"The Must-have VS Code Extension for Node.js Developer"},{"categories":["Coding"],"contents":" How to get My Public IP address Using Java In this tutorial, we will learn About External Public IP address:\nwhat is Public IP address A public IP address is a globally unique IP address that is assigned to a device connected to the internet. It is used to identify and locate devices on the internet, and it allows devices to communicate with each other over the internet.\nPublic IP addresses are assigned by Internet Service Providers (ISPs) to devices that are connected to the internet through them. The devices can be computers, servers, routers, or any other device that is connected to the internet.\nThere are two types of public IP addresses: IPv4 and IPv6. IPv4 addresses are 32-bit numbers that are written in a dot-decimal notation, such as 192.168.0.1. IPv6 addresses are 128-bit numbers that are written in a hexadecimal notation, such as 2001:0db8:85a5:0000:0000:8a2e:0370:6334.\nHow to get My Public IP address Using Java To get your public IP address in Java, you can use the following code:\nimport java.net.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { URL url = new URL(\u0026quot;http://checkip.dyndns.org/\u0026quot;); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream())); String ip = br.readLine(); System.out.println(ip); } } Sample output:\nOutput: \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Current IP Check\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;Current IP Address: 30.5.3.34\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; This code sends a request to the website \u0026ldquo; http://checkip.dyndns.org/\" which returns the client\u0026rsquo;s IP address as a string. The IP address is then read from the response and printed to the console.\nNote that this method relies on an external website to determine the client\u0026rsquo;s IP address, and it may not work if the website is down or if there are any network issues. It is also important to note that this method may not work if the client is behind a NAT (Network Address Translation) or if the client is using a proxy server.\nAlternatively, you can use the InetAddress class to get the client\u0026rsquo;s IP address. Here is an example:\nimport java.net.*; public class Main { public static void main(String[] args) throws Exception { InetAddress addr = InetAddress.getLocalHost(); String ip = addr.getHostAddress(); System.out.println(ip); } } Sample output:\nOutput: 192.168.1.54 This method will return the client\u0026rsquo;s IP address as a string, but it will only return the local IP address of the client if the client is behind a NAT or if the client is using a proxy server.\nAlternative servers If you encounter a problem with the external website server, you can use one of the alternative servers listed below.\nhttps://api.ipify.org https://tnx.nl/ip https://api.infoip.io/ip Free Online IPV4 and IPV6 tool You can also use our WhatIsMyIp free online to get your IP address!\n","permalink":"https://codingactions.com/how-to-get-my-public-ip-address-using-Java/","tags":["Java"],"title":"How to get My Public IP address Using Java"},{"categories":["SEO"],"contents":" SEO Challenges and Best Practices Why SEO Optimization What Is Important? SEO (search engine optimization) is the process of optimizing a website to rank highly in search engine results pages (SERPs) for specific keywords or phrases. When a website ranks highly in search results, it can receive a lot of traffic from users who are searching for the products or services that the website offers.\nSo to rank highly we need to use the top best practices and industry recommendations\nSEO Challenges SEO can be challenging for several reasons:\nConstant updates to search algorithms: Search engines like Google regularly update their algorithms to improve the quality of search results and to reduce spam. This means that the tactics that worked in the past may not work today, and it\u0026rsquo;s important to stay up-to-date with the latest best practices.\nCompetition: With so many websites competing for the same keywords, it can be difficult to rank highly in search results. This is especially true in competitive industries where there are many well-established websites.\nThe need for high-quality content: To rank well in search results, your website needs to have high-quality, informative, and relevant content that provides value to users. Creating this kind of content can be time-consuming and require a lot of effort.\nThe need for a comprehensive approach: SEO involves a wide range of tactics and strategies, from on-page optimization to link building to social media promotion. Implementing all of these tactics effectively requires a comprehensive approach and a lot of time and effort.\nThe importance of user experience: Search engines are increasingly considering user experience factors when ranking websites. This means that it\u0026rsquo;s important to not only optimize your website for search engines, but also to create a good user experience for visitors.\nSEO TOP Best Practices Research and select target keywords: Identify the key phrases that your target audience is searching for and use them throughout your website\u0026rsquo;s content.\nOptimize your website\u0026rsquo;s title tags and meta descriptions: These elements appear in search results and should include your target keywords and a compelling description of your website.\nMake sure your website is mobile-friendly: With more and more people using mobile devices to access the internet, it\u0026rsquo;s important to ensure that your website is mobile-friendly and easy to use on a variety of devices.\nUse header tags effectively: Header tags (H1, H2, etc.) help to structure your website\u0026rsquo;s content and make it easier for search engines to understand the topic of each page.\nOptimize your website\u0026rsquo;s images: Use descriptive, keyword-rich file names and alt text for your images to help search engines understand the content of your website.\nUse internal linking to help search engines discover your website\u0026rsquo;s pages: Linking to relevant pages within your own website can help search engines discover and index more of your website\u0026rsquo;s content.\nUse external linking to improve your website\u0026rsquo;s credibility: Linking to reputable, authoritative websites can help to improve your website\u0026rsquo;s credibility in the eyes of search engines.\nUse social media to promote your website: Share your website\u0026rsquo;s content on social media platforms and interact with your audience to drive traffic to your website.\nCreate high-quality, unique content: Write in-depth, informative content that provides value to your target audience and includes your target keywords.\nUse long-tail keywords: In addition to targeting specific keywords, consider using long-tail keywords (phrases that are more specific and longer) to help attract a more targeted audience.\nOptimize your website\u0026rsquo;s URL structure: Use descriptive, keyword-rich URLs that are easy for both users and search engines to understand.\nUse Google My Business to improve your local SEO: If you have a local business, be sure to claim and optimize your Google My Business listing to improve your visibility in local search results.\nUse **structured dataµµ to help search engines understand your website\u0026rsquo;s content: Structured data (also known as schema markup) can help search engines understand the content of your website and provide more detailed information in search results.\nMake sure your website is fast and responsive: A slow-loading website can hurt your search engine rankings and drive users away. Use tools like Google\u0026rsquo;s PageSpeed Insights to identify and fix performance issues.\nUse analytics tools to track and analyze your results: Use tools like Google Analytics to track your website\u0026rsquo;s performance in search results and identify areas for improvement.\nMonitor and address any crawl errors: Use Google Search Console to identify and fix any crawl errors that may be affecting your website\u0026rsquo;s search engine rankings.\nUse social signals to improve your search engine rankings: Social signals (such as likes, shares, and comments) can help to improve your website\u0026rsquo;s search engine rankings.\nUse a sitemap to help search engines discover and index your website\u0026rsquo;s pages: A sitemap is a list of all the pages on your website that helps search engines discover and index your content.\nMonitor and address any negative SEO attacks: Negative SEO attacks (such as spammy backlinks) can hurt your search engine rankings. Use tools like Ahrefs to monitor for and address any negative SEO attacks.\nKeep up-to-date with the\nGoogle SEO Ressources Google\u0026rsquo;s SEO Starter Guide: https://developers.google.com/search/docs/fundamentals/seo-starter-guide Google\u0026rsquo;s SEO Blog: https://developers.google.com/search/blog ","permalink":"https://codingactions.com/the-ultimate-seo-challenges-and-best-practices-guide/","tags":["SEO","BEST-PRACTICES"],"title":"The Ultimate SEO Challenges and Best Practices Guide"},{"categories":["Automated Testing"],"contents":" Selenium Java Programming Language This post (Picking A Language) is part of a series about Selenium WebDriver with Java .\nIn order to work well with Selenium you need to choose a programming language to write your automated acceptance tests in. Conventional wisdom will tell you to choose the same language that the application is written in. That way if you get stuck you can ask the developers on your team for help. But if you\u0026rsquo;re not proficient in this language (or new to programming), then your progress will be slow and you\u0026rsquo;ll likely end up asking for more of a developer\u0026rsquo;s help than they have time for \u0026ndash; hindering your automation efforts and setting you up for failure.\nA great way to determine which language to go with is to answer one simple question: Who will own the automated tests?\nThe answer to this, and the discussion that unfolds from it, will help you more effectively choose a programming language.\nWhat To Do With The Answer If you\u0026rsquo;re a tester (or a team of testers) and you will be building and maintaining the test automation, then it\u0026rsquo;s best to consider what languages you (and your team) already have experience with, or are interested in working with. Since your Selenium tests don\u0026rsquo;t need to be written in the same language as the application you are testing, have a discussion with your team to see what interests them and go from there.\nIf you\u0026rsquo;re a developer who is working on the application and just looking to add automated acceptance testing to the mix, then it makes sense to continue with the same language.\nSome Additional Food For Thought As your suite of tests grows you will find the need to add functionality to make things easier to use, run faster, offer better reporting, etc. When this happens you will effectively be doing two jobs; no longer just writing automated tests but also building and maintaining a framework (a.k.a. a test harness).\nAs you\u0026rsquo;re considering which language to go with consider what open source frameworks already exist for the languages you are considering. Going with one can save you a lot of time and give you a host of functionality out of the box that you would otherwise have to create yourself \u0026ndash; and they\u0026rsquo;re FREE.\nOutro Choosing a programming language for automated testing is not a decision that should be taken lightly. If you\u0026rsquo;re just starting out then considering and discussing these things will help position you for long term success.\nWith all that being said, the rest of this series will show you how to build your own test harness (in addition to writing well factored tests) in Java with JUnit .\n","permalink":"https://codingactions.com/selenium-with-java-part-3-picking-a-language/","tags":["Selenium","Java","Junit"],"title":"Picking A Language (Java)| Selenium webdriver Java"},{"categories":["Tools"],"contents":"An Free Online tool to check screen resolution of any display device. Using this tool, you can test resolution of your monitor, iPad, tablet, iPhone, MacBook or any other display device.\nYour Screen Resolution is : Screen Width: pixels\nScreen Height: pixels\nIf you need to change your screen resolution in windows, follow these instructions .\nFree Online Multi Screen Test Application You can also use our FREE MULTI SCREEN TEST to test your web site at different screen resolutions \u0026amp; devices\nScreenfly: Multi Screen Test Application What Is Screen Resolution? Screen resolution refers to the number of pixels displayed on a screen, typically measured in width x height. For example, a screen resolution of 1920 x 1080 means that the screen is 1920 pixels wide and 1080 pixels tall. Higher screen resolutions generally result in more detailed and clearer images, but they can also require more processing power to display and may not be as easily visible on smaller screens. The most common screen resolutions for desktop computers are 1920 x 1080 (also known as Full HD or 1080p), 2560 x 1440 (also known as Quad HD or 1440p), and 3840 x 2160 (also known as Ultra HD or 4K). The most common screen resolutions for smartphones are 720 x 1280 (also known as HD), 1080 x 1920 (also known as Full HD or 1080p), and 1440 x 2560 (also known as Quad HD or 1440p).\nSupported devices Netbook and Desktop Netbook: 1024 x 600 Netbook: 1024 x 768 Netbook: 1280 x 800 Netbook: 1366 x 768 Desktop: 1440 x 900 Desktop: 1600 x 900 Desktop: 1680 x 1050 Desktop: 1920 x 1080 Desktop: 1920 x 1200 Tablet Kindle Fire HD 7: 800 x 480 Asus Nexus 7: 960 x 600 Kindle Fire: 1024 x 600 Apple iPad: 1024 x 768 Samsung Galaxy Tab 7: 1024 x 600 Kindle Fire HD 8.9: 1280 x 800 Samsung Galaxy Tab: 1280 x 800 Apple iPad Pro: 1366 x 1024 Microsoft Surface Pro: 1440 x 1024 Go here here for more devices \u0026hellip;\n","permalink":"https://codingactions.com/tools/what-is-my-screen-resolution/","tags":["Screen"],"title":"What Is My Screen Resolution?"},{"categories":["Automated Testing"],"contents":" Google Analytics with Cypress What is Google Analytics Google Analytics is a web analytics service offered by Google that tracks and reports website traffic. It is a free tool that helps website owners and marketers understand how visitors interact with their website, including what pages they visit, how long they stay on the site, and what actions they take.\nGoogle Analytics uses JavaScript code that is inserted into the website\u0026rsquo;s pages to collect data about the site\u0026rsquo;s visitors. The data is then sent to Google\u0026rsquo;s servers, where it is processed and analyzed. The results of this analysis are made available to the website owner through the Google Analytics dashboard, which provides detailed reports and graphs that help to understand the website\u0026rsquo;s performance.\nExample Google Analytics Testing with Cypress Here is an example of how you can use Cypress to test tracking of analytics events in your web application:\ndescribe('Analytics tracking', () =\u0026gt; { beforeEach(() =\u0026gt; { cy.visit('http://localhost:3000'); }); it('tracks pageview on page load', () =\u0026gt; { cy.window().then(win =\u0026gt; { const spy = cy.spy(win.ga, 'send'); cy.wait(1000); // wait for page to fully load expect(spy).to.be.calledWithMatch({ hitType: 'pageview' }); }); }); it('tracks event on button click', () =\u0026gt; { cy.get('button').click(); cy.window().then(win =\u0026gt; { const spy = cy.spy(win.ga, 'send'); expect(spy).to.be.calledWithMatch({ hitType: 'event' }); }); }); }); In this example, we are using the cy.window() and cy.spy() commands to access the ga object (which represents the Google Analytics library) and spy on the send method. We are then using the expect command to verify that the send method is called with the expected arguments (a hit type of \u0026ldquo;pageview\u0026rdquo; or \u0026ldquo;event\u0026rdquo;) when certain actions are taken in the application (page load or button click).\nThis is just one example of how you can use Cypress to test analytics tracking in your application. You can customize the tests to track any specific events or pageviews that you want to verify are being tracked correctly.\n","permalink":"https://codingactions.com/how-to-test-google-analytics-with-cypress/","tags":["Cypress","Javascript","Node.js"],"title":"How to test Google Analytics with Cypress"},{"categories":["Coding"],"contents":" HTTP Requests with Axiosn What are HTTP requests ? HTTP (Hypertext Transfer Protocol) is a protocol for sending and receiving data over the internet. HTTP requests are messages sent by a client (such as a web browser) to a server to request specific information or resources.\nThere are several types of HTTP requests, including GET, POST, PUT, PATCH, and DELETE. Each type of request has a specific purpose and is used to perform a specific action.\nHere is a brief overview of each type of HTTP request:\nGET: A GET request is used to retrieve information from a server. It is the most common type of request and is typically used to request a webpage or other resource from a server.\nPOST: A POST request is used to send data to a server for processing or storage. It is typically used to submit a form or upload a file.\nPUT: A PUT request is used to update a resource on a server. It replaces the existing resource with the one specified in the request.\nPATCH: A PATCH request is used to partially update a resource on a server. It only modifies the specified fields of the existing resource.\nDELETE: A DELETE request is used to delete a resource on a server.\nHTTP requests usually include a set of headers that provide additional information about the request, such as the content type and the accept type. They may also include a body that contains data to be sent to the server.\nAxios library Axios is a popular JavaScript library that allows you to make HTTP requests from the browser or from a Node.js server. It simplifies the process of making HTTP requests by providing a simple, promise-based API that works in both the browser and Node.js.\nTo perform HTTP requests with Axios in JavaScript, you can use the axios library and call one of the request methods: axios.get(), axios.post(), axios.put(), axios.patch(), or axios.delete().\nHere\u0026rsquo;s an example of how to make a GET request to an API endpoint using Axios:\nAxios GET request: axios.get() axios.get('https://api.example.com/endpoint') .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }); The then function is called when the request is successful, and the catch function is called if there is an error. The response object contains the data returned by the API.\nYou can also pass additional options to the Axios request methods, such as the headers, params, and data options. For example:\naxios.get('https://api.example.com/endpoint', { params: { id: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); This sends a GET request to https://api.example.com/endpoint?id=12345, with the id parameter in the query string.\nAxios POST request: axios.post() To make a POST request with Axios in JavaScript, you can use the axios.post() method and pass it the URL of the API endpoint and the data to send in the request body.\nHere\u0026rsquo;s an example of how to make a POST request to an API endpoint using Axios:\naxios.post('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }) .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }); The then function is called when the request is successful, and the catch function is called if there is an error. The response object contains the data returned by the API.\nYou can also pass additional options to the axios.post() method, such as the headers and params options. For example:\naxios.post('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }, { headers: { 'Content-Type': 'application/json' } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); This sends a POST request to https://api.example.com/endpoint with a JSON body containing the firstName and lastName fields.\nAxios PUT request: axios.put() To make a PUT request with Axios in JavaScript, you can use the axios.put() method and pass it the URL of the API endpoint and the data to send in the request body.\nHere\u0026rsquo;s an example of how to make a PUT request to an API endpoint using Axios:\naxios.put('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }) .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }); The then function is called when the request is successful, and the catch function is called if there is an error. The response object contains the data returned by the API.\nYou can also pass additional options to the axios.put() method, such as the headers and params options. For example:\naxios.put('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }, { headers: { 'Content-Type': 'application/json' } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); This sends a PUT request to https://api.example.com/endpoint with a JSON body containing the firstName and lastName fields.\nAxios PUT request: axios.patch() To make a PATCH request with Axios in JavaScript, you can use the axios.patch() method and pass it the URL of the API endpoint and the data to send in the request body.\nHere\u0026rsquo;s an example of how to make a PATCH request to an API endpoint using Axios:\naxios.patch('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }) .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }); The then function is called when the request is successful, and the catch function is called if there is an error. The response object contains the data returned by the API.\nYou can also pass additional options to the axios.patch() method, such as the headers and params options. For example:\naxios.patch('https://api.example.com/endpoint', { firstName: 'John', lastName: 'Doe' }, { headers: { 'Content-Type': 'application/json' } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); This sends a PATCH request to https://api.example.com/endpoint with a JSON body containing the firstName and lastName fields.\nAxios PUT request: axios.delete() To make a DELETE request with Axios in JavaScript, you can use the axios.delete() method and pass it the URL of the API endpoint.\nHere\u0026rsquo;s an example of how to make a DELETE request to an API endpoint using Axios:\naxios.delete('https://api.example.com/endpoint') .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }); The then function is called when the request is successful, and the catch function is called if there is an error. The response object contains the data returned by the API.\nYou can also pass additional options to the axios.delete() method, such as the headers and params options. For example:\naxios.delete('https://api.example.com/endpoint', { params: { id: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); This sends a DELETE request to https://api.example.com/endpoint?id=12345 , with the id parameter in the query string.\n","permalink":"https://codingactions.com/how-to-perform-http-requests-with-axios/","tags":["Axios","Node.js","JavaScript"],"title":"How to Perform HTTP Requests with Axios"},{"categories":["RPA"],"contents":" Puppeteer for Robotic Process Automation Puppeteer and Nodejs for RPA It is possible to use Node.js, a JavaScript runtime environment, in combination with robotic process automation (RPA) tools to automate tasks and processes.\nOne way to do this is by using an RPA tool that has native support for Node.js, such as UiPath or Automation Anywhere. These tools allow you to use Node.js scripts to automate tasks and processes, such as reading and writing data to and from databases or interacting with web applications.\nAlternatively, you can use Node.js to build custom automation solutions by using libraries and frameworks such as Puppeteer or Selenium. These tools allow you to programmatically control a web browser, such as Google Chrome, to perform tasks and interact with web applications.\nHere is an example of using Puppeteer with Node.js to automate a task:\nconst puppeteer = require('puppeteer'); (async () =\u0026gt; { // Launch a new browser instance const browser = await puppeteer.launch(); // Open a new page const page = await browser.newPage(); // Navigate to a website await page.goto('https://www.example.com'); // Perform tasks on the website, such as filling out forms or clicking buttons // Close the browser await browser.close(); })(); This is just a simple example of what you can do with Puppeteer. The library offers a wide range of features and capabilities for automating tasks and processes, such as interacting with web elements, taking screenshots, and generating PDFs.\nPuppeteer can be used in combination with other RPA tools, such as UiPath or Automation Anywhere, to build more advanced automation solutions. It can also be used on its own to automate tasks and processes that involve interacting with web applications.\n","permalink":"https://codingactions.com/puppeteer-robotic-process-automation/","tags":["RPA","Puppeteer","Nodejs","Automation"],"title":"How to use puppeteer for robotic process automation ?"},{"categories":["RPA"],"contents":" Robotic Process Automation What is robotic process automation ? Robotic process automation (RPA) is a type of technology that allows businesses to automate repetitive, rules-based digital tasks that are typically performed by humans. RPA is typically implemented using software \u0026ldquo;bots\u0026rdquo; or \u0026ldquo;robots\u0026rdquo; that are programmed to mimic the actions of a human user, such as logging into an application, navigating through a series of screens, and entering data. These bots are able to operate on multiple applications and systems simultaneously, allowing them to complete complex processes quickly and accurately.\nRPA is often used to automate tasks that are time-consuming or error-prone, such as data entry, processing invoices, or generating reports. It can also be used to automate more complex processes, such as underwriting insurance policies or processing mortgage applications. By automating these tasks, businesses can reduce their reliance on human labor, increase efficiency, and reduce the risk of errors.\nRPA is a relatively new technology, and it is still evolving. It is typically used in conjunction with other technologies, such as artificial intelligence (AI) and machine learning, to create more advanced and sophisticated automation solutions.\nWhat are the advantages of RPA? Robotic process automation (RPA) offers several advantages for businesses that implement it:\nIncreased efficiency: RPA can automate repetitive, rules-based tasks quickly and accurately, freeing up employees to focus on more value-added activities.\nReduced errors: RPA can reduce the risk of errors by automating tasks that are prone to mistakes, such as data entry or processing invoices.\nCost savings: RPA can reduce labor costs by automating tasks that would otherwise be performed by humans.\nImproved compliance: RPA can help businesses to comply with regulations and standards by automating tasks related to compliance.\nScalability: RPA can be scaled up or down as needed to meet changing business needs.\nWhat are the disadvantages of RPA? RPA also has some potential disadvantages to consider:\nInitial costs: Implementing RPA can be expensive, as it requires the purchase of software and may also require the hiring of specialized staff to design and maintain the automation solutions.\nLack of adaptability: RPA is best suited for tasks that are highly structured and predictable. It may not be suitable for tasks that require a high degree of flexibility or creativity.\nDependence on technology: RPA relies on technology to function, so businesses may be vulnerable to disruptions or outages if their systems fail.\nJob displacement: RPA may lead to job displacement for workers who perform tasks that are automated by the technology.\nIntegration challenges: RPA may require significant integration with existing systems and processes, which can be complex and time-consuming.\nWhich tools is used for robotic process automation? There are several tools that can be used for robotic process automation (RPA). Some of the most popular ones include:\nUiPath: UiPath is a leading RPA platform that enables businesses to automate repetitive, rules-based tasks. It offers a range of features, including visual process design, process analytics, and integration with other technologies such as artificial intelligence (AI) and machine learning.\nBlue Prism: Blue Prism is an RPA platform that enables businesses to automate complex processes and integrate with legacy systems. It offers features such as process discovery and design, automation governance, and security.\nAutomation Anywhere: Automation Anywhere is an RPA platform that offers a range of tools for automating tasks, including visual process design, data integration, and analytics.\nWorkFusion: WorkFusion is an RPA platform that combines machine learning and artificial intelligence with traditional RPA to automate complex processes. It offers features such as process discovery, design, and analytics.\nSoftomotive: Softomotive is an RPA platform that offers tools for automating tasks such as data entry, form processing, and invoicing. It offers features such as process design, analytics, and integration with other technologies.\nThese are just a few examples of the many RPA tools that are available. Each tool has its own unique features and capabilities, and businesses should choose the one that best meets their specific automation needs.\nWhat are good use cases for RPA? Robotic process automation (RPA) is well-suited for tasks that are repetitive, rules-based, and require little to no human intervention. Some common use cases for RPA include:\nData entry: RPA can be used to automate the process of entering data into a system, such as filling out forms or inputting customer information.\nInvoice processing: RPA can be used to automate the process of verifying and approving invoices, reducing the time and effort required to process them.\nCustomer service: RPA can be used to automate routine customer service tasks, such as answering frequently asked questions or processing orders.\nCompliance: RPA can be used to automate tasks related to compliance, such as checking for errors or verifying that information is complete and accurate.\nReport generation: RPA can be used to automate the process of generating reports, such as sales or financial reports, saving time and effort.\nInsurance underwriting: RPA can be used to automate the process of underwriting insurance policies, including verifying information and calculating premiums.\nMortgage processing: RPA can be used to automate the process of processing mortgage applications, including verifying information and calculating loan amounts.\nThese are just a few examples of the many use cases for RPA. Businesses can use RPA to automate a wide range of tasks, depending on their specific needs and requirements.\n","permalink":"https://codingactions.com/what-is-robotic-process-automation/","tags":["RPA","Automation"],"title":"What is robotic process automation ?"},{"categories":["Automated Testing"],"contents":"This post (Defining A Test Strategy) is part of a series about Selenium WebDriver with Java .\nA great way to increase your chances of success with automated web testing is to first map out a testing strategy. The best way to do it is to answer these four questions:\nHow does your business make money? What features in your application are being used? What browsers are your users using? What things have broken in the application before? NOTE: For organizations that don\u0026rsquo;t deal directly in dollars and cents (e.g., non-profits, federal agencies, etc.) you should focus on how the application generates value for the end user and the organization.\nAfter answering these questions you will have an understanding of the functionality and browsers that matter for the application you\u0026rsquo;re testing. This will help you focus your efforts on the things that matter most.\nThis strategy works best for applications with existing functionality and does not speak directly to testing new functionality that\u0026rsquo;s being actively developed. That\u0026rsquo;s not to say that the two couldn\u0026rsquo;t co-exist. It largely depends on your available resources and pace of development. But in order to reach high quality at speed, you first have to go slow.\nWhat To Do With The Answers After answering these questions you should end up with a prioritized punch list (a.k.a., backlog) of test automation tasks that you can work off of and track progress against.\nQuestion 1: Money/Value Every company\u0026rsquo;s application makes money (or generates value) through core functionality that is defined by a series of increasingly-valuable user interactions \u0026ndash; a.k.a. a \u0026ldquo;funnel\u0026rdquo;. Your answers to this question will help you determine what your funnel is.\nThese items will be your highest priority for automation. Start an automation backlog to keep track of them.\nQuestion 2: Usage Data Odds are your application offers a robust set of functionality well beyond your funnel. Your answers to this question will help highlight what it is. And if you\u0026rsquo;re basing these answers on usage data (e.g., Google Analytics, etc.), then it will be broken down from highly used to lightly used.\nTack these items onto your automation backlog (below the items from question #1) based on their frequency of use.\nQuestion 3: Browsers Now that you know what functionality is business critical and widely adopted by your users, you need to determine what browsers to focus your automated web testing efforts on. Your usage data will tell you this as well. It will help you determine which browsers you can reasonably avoid testing in (e.g., based on non-existent or low usage numbers).\nNote the top 2 (or 3 depending on your numbers), but focus on the top 1 for now. This is the browser you will start using for automation.\nQuestion 4: Risky Bits To round out the strategy it is also best to think about what things have broken in the application before. To answer this question it\u0026rsquo;s best to check your defect/bug tracker (if you have one) and to ask your team. What you end up with may read like a laundry list of browser specific issues or functionality that has been flaky or forgotten about in the past. But it\u0026rsquo;s all useful information.\nBe sure to check this list against your automation backlog. If something\u0026rsquo;s not there, add it to the bottom of the backlog. If it is there, make a note in the backlog item that it has been an issue in the past.\nIf the issue has happened numerous times and has the potential to occur again, move the item up in the backlog. And if issues keep cropping up that are related to a specific browser, compare this browser to your short list of browsers from question #3. If it\u0026rsquo;s a browser that\u0026rsquo;s not in your list but it\u0026rsquo;s still important (e.g., a small pocket of influential users), track it on the backlog, but put it at the bottom.\nNow You Are Ready Having answered these questions, you should now have a prioritized backlog of critical business functionality, a short list of browsers to focus on, and an understanding of the risky parts of your application to watch out for. With it, you\u0026rsquo;re on the right track \u0026ndash; focusing on things that matter for your business and its users.\n","permalink":"https://codingactions.com/selenium-with-java-part-2-defining-a-test-strategy/","tags":["Selenium","Java"],"title":"Defining A Test Strategy | Selenium webdriver Java"},{"categories":["Automated Testing","Selenium"],"contents":"This post is part of a series about Selenium WebDriver with Java .\nSelenium is a software robot sent from the future to help us test web applications. But keep in mind that it\u0026rsquo;s not one of those fancy shape-shifting robots than can run really fast. It\u0026rsquo;s more like one of those really strong robots that\u0026rsquo;s not very fast and is best suited for accomplishing a certain objective.\nThat is to say Selenium is really good at a specific set of things. If you know what those are and stick to them then you can easily write reliable, scalable, and maintainable tests that you and your team can trust.\nWhat Selenium Is and Is Not Good At Selenium is built to automate browsers, specifically human interaction with them. Things like navigating to pages, clicking on elements, typing text into input fields, etc.\nIt\u0026rsquo;s less ideal for checking lower-level functionality like HTTP status codes or HTTP headers. While you can use Selenium this way, it requires additional setup of a third-party tool (e.g., a proxy server like BrowserMob Proxy ), and it is a slippery slope since there are numerous edge cases to consider at this level.\nSelenium Highlights Selenium works on every major browser, in every major programming language, and on every major operating system. Each language binding and browser are actively being developed to stay current. Yes, even Internet Explorer (thanks to Jim Evans !). And WebDriver (the thing which drivers Selenium) has become a W3C specification .\nSelenium can be run on your local computer, on a remote server, on a set of servers (with Selenium Grid), or on a third-party cloud provider. As your test suite grows, your test runs will take longer to complete. To speed them up you will want to run them in parallel, which is where the benefit of having your own servers or using a cloud provider comes in \u0026ndash; that, and the ability to have numerous browser and operating system combinations to run your tests on.\nOne of the guiding philosophies of Selenium is to be able to write your tests once and run them across multiple browsers. While this is a rosy proposition, it\u0026rsquo;s not entirely accurate. There are some gotchas to watch out for when you get into it.\n","permalink":"https://codingactions.com/selenium-with-java-part-1-selenium-in-a-nutshell/","tags":["Selenium","Automated Testing","Java"],"title":"Selenium webdriver with Java: Selenium In A Nutshell"},{"categories":["Automated Testing","Selenium"],"contents":"This blog series steps through the process of writing Selenium WebDriver UI tests in Java from the first line of code through to running tests at scale in the cloud.\nSelenium In A Nutshell Defining A Test Strategy Picking A Language ","permalink":"https://codingactions.com/selenium-with-java-toc/","tags":["Selenium","Automated Testing","Java"],"title":"Selenium webdriver with Java: Table of Contents"},{"categories":["Automated Testing"],"contents":"This post (Automating Your Test Runs) is part of a series about Selenium WebDriver with Node.js .\nYou\u0026rsquo;ll probably get a lot of mileage out of your test suite in its current form if you just run things from your computer, look at the results, and tell people when there are issues. But that only helps you solve part of the problem.\nThe real goal in test automation is to find issues reliably, quickly, and automatically. We\u0026rsquo;ve built things to be reliable and quick. Now we need to make them run on their own, and ideally, in sync with the development workflow you are a part of.\nTo do that we need to use a Continuous Integration server.\nA Continuous Integration Server Primer A Continuous Integration server (a.k.a. CI) is responsible for merging code that is actively being developed into a central place (e.g., \u0026ldquo;trunk\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, or \u0026ldquo;master\u0026rdquo;) frequently (e.g., several times a day, or on every code commit) to find issues early so they can be addressed quickly — all for the sake of releasing working software in a timely fashion.\nWith CI we can automate our test runs so they can happen as part of the development workflow. The lion’s share of tests that are typically run on a CI Server are unit (and potentially integration) tests. But we can very easily add in our Selenium tests too.\nThere are numerous CI Servers available for use today, most notably:\nBambooCI CircleCI Jenkins TravisCI Let\u0026rsquo;s pick one and step through an example.\nA CI Example Jenkins is a fully functional, widely adopted, free and open-source CI server. Its a great candidate for us to try.\nLets start by setting it up on the same machine as our test code. Keep in mind that this isn’t the \u0026ldquo;proper\u0026rdquo; way to go about this — its merely beneficial for this example. To do it right, the Jenkins server (e.g., master node) would live on a machine of its own.\nPart 1: Quick Setup A simple way to get started is to grab the latest Jenkins war file. You can grab it from the Jenkins download page .\nOnce downloaded, launch it from the command-line and follow the setup steps provided.\n\u0026gt; java -jar jenkins.war // ... hudson.WebAppMain$3 run INFO: Jenkins is fully up and running You will now be able to use Jenkins by visiting http://localhost:8080/ in your browser.\nJenkins Home Screen NOTE: Before moving to the next step, click ENABLE AUTO-REFRESH at the top right-hand side of the page. Otherwise you\u0026rsquo;ll need to manually refresh the page (e.g., when running a job and waiting for results to appear).\nPart 2: Job Creation And Configuration Now that Jenkins is loaded in the browser, let\u0026rsquo;s create a Job and configure it to run our shallow tests against Chrome on Windows 10.\nClick New Item from the top-left of the Dashboard Give it a name (e.g., Shallow Tests Chrome 50 Windows 10) Select the Freestyle project option Click OK Alt Jenkins New Job This will load a configuration screen for the Jenkins job.\nJenkins Job Configuration In the Advanced Project Options section select the Advanced button Choose the checkbox for Use custom workspace Provide the full path to your test code Leave the Display Name field blank Jenkins Advanced Job Configuration NOTE: Ideally, your test code would live in a version control system and you would configure your job (under Source Code Management) to pull it in and run it. To use this approach you may need to install a plugin to handle it. For more info on plugins in Jenkins, go here .\nScroll down to the Build section and select Add build step Select Execute shell Specify the commands needed to launch the tests Jenkins Job Configuration Add Build Step Jenkins Job Configuration Build Step BROWSER=chrome BROWSER_VERSION=75 PLATFORM='Windows 10' mocha-parallel-tests --grep=@shallow -R xunit test/*Test.js \u0026gt; test-result.xml -R xunit specifies the reporter we\u0026rsquo;d like to use for the test results. xunit will give us an XML report that Jenkins expects. Now let\u0026rsquo;s hop back over to Jenkins and configure the job to consume the test results.\nUnder Post-build Actions select Add post build action Select Publish JUnit test result report Add the name of the result file specified in the command \u0026ndash; test-result.xml Click Save NOTE: If this post build action isn\u0026rsquo;t available to you, you will need to install the JUnit Jenkins plugin .\nJenkins Job Add Post Build Action Alt Jenkins Job Post Build Action Now our tests are ready to be run, but before we do, let\u0026rsquo;s go ahead and add a failing test so we can demonstrate the test report.\nPart 3: Force A Failure Let\u0026rsquo;s add a new test method to LoginTest.js that will fail every time we run it.\n// filename: test/LoginTest.js // ... it.only('forced failure @shallow', async function() { await login.authenticate('tomsmith', 'bad password') assert.equal(false, true) }) This test mimics our 'with invalid credentials @deep' test by visiting the login page and providing invalid credentials. The differences here are in the assertion and the tag. It will fail since false is not true, and we want it to run as part of our @shallow suite.\nOne more thing we\u0026rsquo;ll want to do is update how we\u0026rsquo;re outputting the Sauce Labs job URL when there\u0026rsquo;s a test failure. Right now we\u0026rsquo;re outputting it to the console, but with the XML report generation this information will be hard to find in our Jenkins job. So let\u0026rsquo;s make sure it shows up in the stack trace, and ultimately, the final test result report.\n// filename: lib/DriverFactory.js // ... async quit(testPassed) { if (this.config.host === 'saucelabs') { this.driver.executeScript('sauce:job-name=' + this.testName) this.driver.executeScript('sauce:job-result=' + testPassed) } await this.driver.quit() if (this.config.host === 'saucelabs' \u0026amp;\u0026amp; !testPassed) { throw new Error( 'See a video of the run at https://saucelabs.com/tests/' + this.sessionId ) } } } module.exports = DriverFactory In the quit method of our Driver Factory we make it so we throw an exception with the Sauce Labs job URL when there\u0026rsquo;s a test failure. We also move it to fire after calling driver.quit() to ensure that the job in Sauce Labs terminates correctly. This change will make the job URL show up in a relevant spot in the XML test report.\nNow let\u0026rsquo;s run our Jenkins job by clicking Build Now from the left-hand side of the screen.\nNOTE: You can peer behind the scenes of a job while it\u0026rsquo;s running (and after it completes) by clicking on the build you want from Build History and selecting Console Output. This output will be your best bet in tracking down an unexpected result.\nWhen the test completes, it will be marked as failed.\nJenkins Job Screen With Failure When we click on Latest Test Result we can see the test that failed (e.g., Login.forced failure @shallow). The other failure listed (e.g., ,\u0026quot;after each\u0026quot; hook for \u0026quot;forced failure @shallow\u0026quot;) is from the teardown of our test. It contains the Sauce Labs job URL.\nJenkins Job Test Result If we click on the failed test we can see the stack trace from the test failure. If we click on the failure from the teardown we can see the URL to the job in Sauce Labs.\nJenkins Job Test Result Individual When we follow the URL to the Sauce Labs job we\u0026rsquo;re able to see what happened during the test run (e.g., we can replay a video of the test, see what Selenium commands were issued, etc.).\nSauce Labs Job Notifications In order to maximize your CI effectiveness, you\u0026rsquo;ll want to send out notifications to alert your team members when there\u0026rsquo;s a failure.\nThere are numerous ways to go about this (e.g., e-mail, chat, text, co-located visual cues, etc). Thankfully there are numerous, freely available plugins that can help facilitate whichever method you want. You can find out more about Jenkins\u0026rsquo; plugins here .\nFor instance, if you wanted to use chat notifications and you use a service like Slack, you would do a plugin search:\nJenkins Plugin Slack After installing the plugin, you will need to provide the necessary information to configure it (e.g., an authorization token, the channel/chat room where you want notifications to go, what kinds of notifications you want sent, etc.) and then add it as a Post-build Action to your job (or jobs).\nAfter installing and configuring a plugin, when your CI job runs and fails, a notification will be sent to the chat room you configured.\nIdeal Workflow In the last chapter we covered test grouping with categories and applied some preliminary ones to our tests (e.g., \u0026ldquo;Shallow\u0026rdquo; and \u0026ldquo;Deep\u0026rdquo;). These categories are perfect for setting up an initial acceptance test automation workflow.\nTo start the workflow we\u0026rsquo;ll want to identify a triggering event. Something like a CI job for unit or integration tests that the developers on your team use. Whenever that runs and passes, we can trigger our \u0026ldquo;Shallow\u0026rdquo; test job to run (e.g., our smoke or sanity tests). If the job passes then we can trigger a job for \u0026ldquo;Deep\u0026rdquo; tests to run. Assuming that passes, we can consider the code ready to be promoted to the next phase of release (e.g., manual testing, push to a staging, etc.) and send out a relevant notification to the team.\nNOTE: You may need to incorporate a deployment action as a preliminary step before your \u0026ldquo;Shallow\u0026rdquo; and \u0026ldquo;Deep\u0026rdquo; jobs can be run (to make sure your tests have an environment available to be run against). Consult a developer on your team for help if that\u0026rsquo;s the case.\nOutro By using a CI Server you\u0026rsquo;re able to put your tests to work by using computers for what they\u0026rsquo;re good at \u0026ndash; automation. This frees you up to focus on more important things. But keep in mind that there are numerous ways to configure your CI server. Be sure to tune it to what works best for you and your team. It\u0026rsquo;s well worth the effort.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-15-automating-your-test-runs/","tags":["Selenium","Javascript","Node.js"],"title":"Automating Your Test Runs | Selenium webdriver nodejs"},{"categories":["Coding"],"contents":"The Problem If you\u0026rsquo;re working on a test that intermittently fails, it\u0026rsquo;s useful to have a snippet that will run your test again and again until it fails. This is both to get to the state that it\u0026rsquo;s failing easier, and to prove that most likely, the bug is fixed (if it doesn\u0026rsquo;t fail after 5 test runs, chances are it\u0026rsquo;s no longer an issue).\nWhile you could just manually re-run your test again and again until it fails, what if you\u0026rsquo;re lazy and want to automatically restart the test if it passed?\nA Solution This shell function can be added to your .bashrc file (or whatever file your terminal program auto-loads on startup)\nWithout using a fixed number of times function untilfail() { while $@; do :; done } Then, after sourcing that file (or restarting your terminal), you can use it to run your Selenium , WebdriverIO , Cypress script or any type of Linux commands:\nExample of use with Mocha $ untilfail npx mocha --spec login-tests.js Example of use with WebdriverIO $ untilfail npx wdio --spec=login-test.js Example of use with selenium $ untilfail npm run login-test Using a fixed number of times Want to just run it a set number of times? Here\u0026rsquo;s a different function you can use:\nfunction run() { number=$1 shift for i in `seq $number`; do $@ done } To use it to run wdio 5 times, pass in the number after the command:\nExample of use with Mocha $ run 6 npx mocha --spec login-tests.js Note that this second version won\u0026rsquo;t stop running if there\u0026rsquo;s a test failure. It\u0026rsquo;ll keep running until you force it to stop, or it goes through the number of runs you requested.\n","permalink":"https://codingactions.com/how-to-repeat-a-command-until-it-fails/","tags":["Automation","Programming","Flaky Test"],"title":"How to repeat a command until it fails"},{"categories":["Automated Testing"],"contents":"This post (Flexible Test Execution) is part of a series about Selenium WebDriver with Node.js .\nIn order to get the most out of our tests we\u0026rsquo;ll want a way to break them up into relevant, targeted chunks. Running tests in smaller groupings like this (along with parallel execution) will help keep test run times to a minimum and help enhance the amount of feedback you get in a timely fashion.\nWith Mocha\u0026rsquo;s --grep feature we\u0026rsquo;re able to easily achieve test grouping (a.k.a. tags).\nLet\u0026rsquo;s step through how to set this up.\nSpecifying Tags Grep is a simple text match function. It will look through the test files and execute them if it found a match for a given string pattern. To make this work we\u0026rsquo;ll want to add some metadata to our test names with with a special character to make it stand out as metadata so it\u0026rsquo;s easier to search for.\nSome simple examples of this are @shallow and @deep. @shallow tests are roughly equivalent to \u0026ldquo;smoke\u0026rdquo; or \u0026ldquo;sanity\u0026rdquo; tests. These should pass before you can consider running other tests which aren\u0026rsquo;t as mission critical and may take longer to run (e.g., @deep tests).\nLet\u0026rsquo;s update our tests to apply these \u0026ldquo;tags\u0026rdquo;.\n// filename: test/LoginTest.js // ... it('with valid credentials @shallow', async function() { // ... it('with invalid credentials @deep', async function() { // ... In LoginTest.js we updated the test names directly. The happy path test is now marked as @shallow and the invalid credentials test as @deep. Now let\u0026rsquo;s apply the @deep marker to the entire class in DynamicLoadingTest.js.\n// filename: test/DynamicLoadingTest.js // ... describe('Dynamic Loading @deep', function() { // ... Tags are powerful since they can be applied across different test files, enabling you to create a dynamic grouping of tests at runtime.\nRunning Tags With both Mocha and mocha-parallel-tests we can specify which marker to launch at runtime. This is handled as another runtime flag on the command-line using --grep.\nmocha --grep @shallow mocha-parallel-tests --grep @shallow ","permalink":"https://codingactions.com/selenium-with-nodejs-part-14-flexible-test-execution/","tags":["Selenium","Javascript","Node.js"],"title":"Flexible Test Execution | Selenium webdriver nodejs"},{"categories":["Tools"],"contents":"Find out what your public IPv4 and IPv6 address is revealing about you!\nMy Public IP Information IPv4 is: IPv6 is: What Is An IP Address? IP address stands for Internet Protocol Address. An IP is a unique number assigned to all information technology connected devices such as printers, routers, modems, and even refrigerators.\nThe IP address identifies and allows these devices the ability to communicate with each other on an internal or external computer network. Any device that transmits or receives internet traffic will be assigned an IP address.\n","permalink":"https://codingactions.com/tools/whatismyip/","tags":["IPv4","IPv6"],"title":"What Is My IP Address?"},{"categories":["Automated Testing"],"contents":"This post (Speeding Up Your Test Runs) is part of a series about Selenium WebDriver with Node.js .\nWe\u0026rsquo;ve made huge strides by leveraging page objects, a base page object, explicit waits, and connecting our tests to Sauce Labs. But we\u0026rsquo;re not done yet. Our tests still take a good deal of time to run since they\u0026rsquo;re executing in series (e.g., one after another). As our suite grows this slowness will grow with it.\nWith parallelization we can easily remedy this pain before it becomes acute by executing multiple tests at the same time.\nThankfully, this is simple to accomplish with mocha-parallel-tests .\nSetup First we need to install mocha-parallel-tests. So let\u0026rsquo;s update our package.json file and use npm install to install it.\n// filename: package.json { \u0026quot;name\u0026quot;: \u0026quot;selenium-guidebook-examples\u0026quot;, \u0026quot;dependencies\u0026quot;: { \u0026quot;mocha\u0026quot;: \u0026quot;^6.1.4\u0026quot;, \u0026quot;mocha-parallel-tests\u0026quot;: \u0026quot;2.1.0\u0026quot;, \u0026quot;selenium-webdriver\u0026quot;: \u0026quot;^4.3.0\u0026quot; } } NOTE: Alternatively we could have installed the library and have our package.json file auto-updated by using npm install package-name --save.\nOnce installed you can run mocha tests in parallel through the binary executor provided by mocha-parallel-tests.\nmocha-parallel-tests test/*Test.js The concurrency limit for parallel execution can be controlled with the --max-parallel command-line flag. By default it\u0026rsquo;s set to the number of CPU cores on your computer.\nNOTE: If you\u0026rsquo;re using Sauce Labs you\u0026rsquo;ll have a concurrency limit (e.g., number of available concurrent virtual machines you can use). It\u0026rsquo;s listed on the My Account page in the Account Dashboard . This number will be the limiter to how many parallel tests you can run at once. If you send more jobs than your concurrency limit, Sauce Labs will queue the excess and run them as the initial batch of jobs finish.\nRandom Order Execution When enabling parallel execution in your tests you may start to see odd, inconsistent behavior that is hard to track down.\nThis can be due to dependencies between tests that you didn\u0026rsquo;t know were there. A great way to expose these kinds of issues and ensure your tests are ready for prime time is to execute them in a random order. This also has the added benefit of exercising the application you\u0026rsquo;re testing in a random order (which could unearth previously unnoticed bugs).\nThis is functionality which is still being built for Mocha, so it\u0026rsquo;s not available yet. But you can follow along with its progress here .\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-13-speeding-up-your-test-runs/","tags":["Selenium","Javascript","Node.js"],"title":"Speeding Up Your Test Runs | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Running Browsers In The Cloud) is part of a series about Selenium WebDriver with Node.js .\nIf you\u0026rsquo;ve ever needed to test features in an older browser like Internet Explorer 9 or 10 then odds are you ran a virtual machine (VM) on your computer with a \u0026ldquo;legit\u0026rdquo; version of Windows.\nHandy, but what happens when you need to check things on multiple versions of IE? Now you\u0026rsquo;re looking at multiple VMs. And what about when you need cover other browser and Operating System (OS) combinations? Now you\u0026rsquo;re looking at provisioning, running, and maintaining your own set of machines and standing up something like Selenium Grid to coordinate tests across them.\nRather than take on the overhead of a test infrastructure you can easily outsource this to a third-party cloud provider like Sauce Labs .\nA Selenium RemoteWebDriver, Selenium Grid, and Sauce Labs Primer At the heart of Selenium at scale is the use of Selenium Grid and Selenium RemoteWebDriver.\nSelenium Grid lets you distribute test execution across several machines and you connect to it with Selenium RemoteWebDriver. You tell the Grid which browser and OS you want your test to run on through the use of Selenium\u0026rsquo;s exported class object selenium-webdriver.Capabilities (i.e. DesiredCapabilities) , and its various subclasses for specific browser options (Capabilities.chrome(), Capabilities.firefox(), etc.)\nGenerally speaking, running tests on Sauce Labs is similar to running tests on a Selenium Grid behind the scenes. They receive and execute tests through Selenium RemoteWebDriver with the browser and operating system that you set. Sauce Labs has specific language bindings that act as wrappers for supported programming languages. This makes connecting and working with the Sauce Labs platform much easier.\nLet\u0026rsquo;s dig in with an example.\nAn Example Part 1: Initial Setup NOTE: You\u0026rsquo;ll need an account to use Sauce Labs. Their free trial offers enough to get you started. And if you\u0026rsquo;re signing up because you want to test an open source project, then be sure to check out their Open Sauce account .\nWith Sauce Labs we need to provide specifics about what we want in our test environment, our credentials, and configure Selenium a little bit differently. Let\u0026rsquo;s start by updating our config.js file to store these details.\n// filename: lib/config.js module.exports = { baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com', browser: process.env.BROWSER || 'firefox', host: process.env.HOST || \u0026quot;localhost\u0026quot;, sauce: { username: process.env.SAUCE_USERNAME, accessKey: process.env.SAUCE_ACCESS_KEY, browserName: process.env.BROWSER_NAME || 'internet explorer', browserVersion: process.env.BROWSER_VERSION || \u0026quot;11.0\u0026quot; platformName: process.env.PLATFORM_NAME || \u0026quot;Windows 7\u0026quot;, }, } In addition to the baseUrl, browser, and viewportSize variables, we\u0026rsquo;ve added some more (e.g., host, username, accessKey, platform, browserName, and version).\nhost enables us to specify whether our tests run locally or on Sauce Labs. The others are stored under a key sauce key to make their use explicit.\nWith the combination of platform, browserName, and version we can specify which browser and operating system combination we want our tests to run on. You can see a full list of Sauce\u0026rsquo;s available platform options here . They also have a handy configuration generator (which will tell you what values to plug into your test suite at run-time) here .\nNow we can update our Driver Factory to work with these new values and connect to Sauce Labs.\n// filename: lib/DriverFactory.js // ... class DriverFactory { constructor(config) { this.config = config } _configure() { let builder = new Builder() switch (this.config.host) { case 'saucelabs': const url = 'https://ondemand.saucelabs.com/wd/hub' builder.usingServer(url) builder.withCapabilities(this.config.sauce) break case 'localhost': process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor') builder.forBrowser(this.config.browser) break } return builder } // ... async build() { this.driver = await this._configure().build() } } module.exports = DriverFactory We create a method to configure the builder object for Selenium (e.g., _configure()), wrapping everything in a conditional check against config.host. If it\u0026rsquo;s set to 'saucelabs' then we specify the url for their on-demand end-point and pass in the capabilities that we want (e.g., everything specified under sauce in config.js). If config.host is set to 'localhost' then we handle browser execution just like before (adding the path to the vendor directory to the execution path and launching a browser locally).\nNOTE: In JavaScript, functions or methods prefixed with a _ are intended to be private.\nIf we save everything and run our tests they will execute in Sauce Labs and on the account dashboard we\u0026rsquo;ll see our tests running in Internet Explorer 11 on Windows 7.\nTo run the tests on different browser and operating system combinations, then simply provide their values as command-line options (e.g., BROWSER_NAME='name' BROWSER_VERSION=version PLATFORM_NAME='os' mocha). For a full list of possible options be sure to check out the Sauce Labs Platform Configurator .\nPart 2: Test Name It\u0026rsquo;s great that our tests are running on Sauce Labs. But we\u0026rsquo;re not done yet because the test name in each Sauce job is getting set to unnamed job. This makes it extremely challenging to know what test was run in the job. To remedy this we\u0026rsquo;ll need to pass the test name to Sauce Labs somehow.\nGiven the order of operations of our test code, we only have access to the test name after the test has completed. So we\u0026rsquo;ll account for this in both the quit method of our Driver Factory and the global afterEach in our Base Test. Let\u0026rsquo;s start with the Driver Factory first.\n// filename: lib/DriverFactory.js async build(testName) { this.testName = testName this.driver = await this._configure().build() } // ... async quit() { if (this.config.host === 'saucelabs') { this.driver.executeScript('sauce:job-name=' + this.testName) } await this.driver.quit() } } module.exports = DriverFactory We need to amend build to receive a testName and store it for later use. Then with Selenium we have access to execute JavaScript directly in the browser session. When executing tests in Sauce Labs we have access to pass information to them about the current job through JavaScript calls. We take advantage of this fact by specifying the name of the job for the session. And we only want this to happen when our tests are executing in Sauce Labs, so we wrap this in a conditional check.\nNow to update our spec_helper to pass the testName.\n// filename: test/spec_helper.js // ... beforeEach(async function() { const testName = this.currentTest.fullTitle() await driverFactory.build(testName) this.driver = driverFactory.driver }) // ... Now when we run our tests in Sauce Labs, the account dashboard will show the tests running with a correct name.\nPart 3: Test Status There\u0026rsquo;s still one more thing we\u0026rsquo;ll need to handle, and that\u0026rsquo;s setting the status of the Sauce Labs job after it completes.\nRight now regardless of the outcome of a test, the job in Sauce Labs will register as Finished. Ideally we want to know if the job was a Pass or a Fail. That way we can tell at a glance if a test failed or not. With a couple of tweaks we can make this happen easily enough.\nFirst we need to update our build method in the Driver Factory to grab the session ID from Selenium.\n// filename: lib/DriverFactory.js // ... async build(testName) { // ... this.driver = await this._configure().build() const { id_ } = await this.driver.getSession() this.sessionId = id_ // ... } Next, we need to update the quit method in the Driver Factory.\n// filename: lib/DriverFactory.js // ... async quit(testPassed) { if (this.config.host === 'saucelabs') { this.driver.executeScript('sauce:job-name=' + this.testName) this.driver.executeScript('sauce:job-result=' + testPassed) if (!testPassed) console.log( 'See a video of the run at https://saucelabs.com/tests/' + this.sessionId ) } await this.driver.quit() } } module.exports = DriverFactory With the JavaScript executor we\u0026rsquo;re able to pass in the test result just like the name, which we\u0026rsquo;re getting as a parameter on this method. And for good measure we\u0026rsquo;ve also put the testResult to good use by outputting a URL of the Sauce Labs job to the console if there is a test failure. That way we\u0026rsquo;ll have easy access to the direct URL of the job to review what happened in the test.\nNow let\u0026rsquo;s update the afterEach in our spec helper.\n// filename: test/spec_helper.js // ... afterEach(async function() { const testPassed = this.currentTest.state === 'passed' await driverFactory.quit(testPassed) }) We grab the state of the current test (e.g., this.currentTest.state), check to see if it passed (e.g., === 'passed'), and pass it into driverFactory.quit.\nNow when we run our tests in Sauce Labs and navigate to the Sauce Labs Account dashboard , we will see our tests running like before. But now there will be a proper test status when they finish (e.g., Pass or Fail) and we\u0026rsquo;ll see the URL for the job in the console output as well. This enables us to easily jump to the specific job in Sauce Labs.\nPart 4: Sauce Connect There are various ways that companies make their pre-production application available for testing. Some use an obscure public URL and protect it with some form of authentication (e.g., Basic Auth, or certificate based authentication). Others keep it behind their firewall. For those that stay behind a firewall, Sauce Labs has you covered.\nThey have a program called Sauce Connect Proxy that creates a secure tunnel between your machine and their private cloud. With it you can run tests in Sauce Labs and test applications that are only available on your private network.\nTo use Sauce Connect you need to download and run it. There\u0026rsquo;s a copy for each operating system \u0026ndash; get yours here and run it from the command-line. In the context of our existing test code let\u0026rsquo;s download Sauce Connect, unzip its contents, and store it in our vendor directory.\n├── lib │ ├── DriverFactory.js │ └── config.js ├── package.json ├── pages │ ├── BasePage.js │ ├── DynamicLoadingPage.js │ └── LoginPage.js ├── test │ ├── DynamicLoadingTest.js │ ├── LoginTest.js │ ├── mocha.opts │ └── spec_helper.js └── vendor ├── chromedriver └── geckodriver └── sc Now we just need to launch the application while specifying our Sauce account credentials.\nvendor/sc -u $SAUCE_USERNAME -k $SAUCE_ACCESS_KEY // ... Starting Selenium listener... Establishing secure TLS connection to tunnel... Selenium listener started on port 4445. Sauce Connect is up, you may start your tests. Now that the tunnel is established, we could run our tests against a local instance of our application (e.g., the-internet ). Assuming the application was set up and running on our local machine, we run our tests against it by specifying a different base URL at runtime (e.g., BASE_URL=http://localhost:4567 mocha) and they would work.\nTo see the status of the tunnel, we can view it on the tunnel page of the account dashboard . To shut the tunnel down, we can do it manually from this page. Or we can issue a Ctrl+C command to the terminal window where it\u0026rsquo;s running.\nWhen the tunnel is closing, here\u0026rsquo;s what you\u0026rsquo;ll see.\nGot signal 2 Cleaning up. Removing tunnel 21ff9664b06c4edaa4bd573cdc1fbac1. All jobs using tunnel have finished. Waiting for the connection to terminate... Connection closed (8). Goodbye. ","permalink":"https://codingactions.com/selenium-with-nodejs-part-12-running-browsers-in-the-cloud/","tags":["Selenium","Javascript","Node.js","Cloud","Browserstack","SauceLabs"],"title":"Running Browsers In The Cloud | Selenium webdriver nodejs"},{"categories":["SEO"],"contents":"After researching your keywords and writing an article around the subject, use the SEO checklist below to optimize your article:\nBold Keyword Italicized Keyword Underlined Keyword\na. Make this a hyperlink (www.yourwebsite.com) to another page in your website Insert a picture and make sure its name and ALT tag is the keyword Make the first word in the blog post the keyword Have an H1, H2 and H3 Tag containing the keyword in your article. Make sure blog post URL contains keyword: www.yourwebsite.com/how-to-keyword/ Create an internal link to another blog post on your site relating to topic at hand (if possible). Create an outbound link pointing to another website (that you don\u0026rsquo;t own). Have the last 50 words of your article contain the keyword. Have a keyword density of 1% to 3% Make sure your title is 70 characters or less Article should be 300 words in length MINIMUM. ","permalink":"https://codingactions.com/write-the-perfect-seo-optimized-article/","tags":["Tips"],"title":"The Perfect SEO Optimized Article"},{"categories":["Automated Testing"],"contents":"This post (Running A Different Browser Locally) is part of a series about Selenium WebDriver with Node.js .\nNow that we have some tests and page objects, we\u0026rsquo;ll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.\nPart 1: Global Setup \u0026amp; Teardown We\u0026rsquo;ll start by pulling the Selenium setup and teardown out of our tests and into a central location.\nWe\u0026rsquo;ll create three things. A class that will contain the creation and destruction of our Selenium instances (a.k.a. a Driver Factory), a helper that all tests will pull from, and an option file Mocha uses to store commonly used command-line arguments.\nIn the lib directory we\u0026rsquo;ll create a new file called DriverFactory.js, and in the test directory we\u0026rsquo;ll create files called spec_helper.js and mocha.opts.\n├── lib │ └── DriverFactory.js ├── package.json ├── pages │ ├── BasePage.js │ ├── DynamicLoadingPage.js │ └── LoginPage.js ├── test │ ├── DynamicLoadingTest.js │ ├── LoginTest.js │ ├── mocha.opts │ └── spec_helper.js └── vendor └── geckodriver Here are the initial contents of the Driver Factory.\n// filename: lib/DriverFactory.js const path = require('path') const { Builder } = require('selenium-webdriver') class DriverFactory { async build() { process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor') this.driver = await new Builder().forBrowser('firefox').build() } async quit() { await this.driver.quit() } } module.exports = DriverFactory After requiring our requisite libraries, we declare a class along with two methods \u0026ndash; build, and quit. build is responsible for creating an instance of Selenium and quit is responsible for destroying the Selenium instance.\nThe class ends with module.exports, just like in previous classes we\u0026rsquo;ve created.\nNow to update our mocha.opts file. It\u0026rsquo;s a small change that will help us clean up the hard-coded timeout that we\u0026rsquo;ve needed to specify in each test.\n// filename: test/mocha.opts -t 60000 Now let\u0026rsquo;s put everything to use in our spec helper.\n// filename: test/spec_helper.js const DriverFactory = require('../lib/DriverFactory') const driverFactory = new DriverFactory() beforeEach(async function() { await driverFactory.build() this.driver = driverFactory.driver }) afterEach(async function() { await driverFactory.quit() }) In Mocha, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as root-level hooks.\nAt the top of the spec helper we require the Driver Factory and create a new instance of it, storing it in a variable.\nIn beforeEach we create a driver instance and store it in a variable on this (which will make it accessible to the test).\nIn afterEach we call the quit method in the Driver Factory to destroy the Selenium instance.\nNow to update our tests.\n// filename: test/LoginTest.js require('./spec_helper') const assert = require('assert') const LoginPage = require('../pages/LoginPage') describe('Login', function() { let login beforeEach(async function() { login = new LoginPage(this.driver) await login.load() }) it('with valid credentials', async function() { await login.authenticate('tomsmith', 'SuperSecretPassword!') assert(await login.successMessagePresent(), 'Success message not displayed') }) it('with invalid credentials', async function() { await login.authenticate('tomsmith', 'bad password') assert(await login.failureMessagePresent(), 'Failure message not displayed') }) }) // filename: test/DynamicLoadingTest.js require('./spec_helper') const assert = require('assert') const DynamicLoadingPage = require('../pages/DynamicLoadingPage') describe('Dynamic Loading', function() { let dynamicLoading beforeEach(async function() { dynamicLoading = new DynamicLoadingPage(this.driver) }) it('hidden element', async function() { await dynamicLoading.loadExample('1') assert( await dynamicLoading.isFinishTextPresent(), true, 'Finish text not displayed' ) }) it('rendered element', async function() { await dynamicLoading.loadExample('2') assert( await dynamicLoading.isFinishTextPresent(), true, 'Finish text not displayed' ) }) }) In order to use the spec helper we just need to require it.\nThen we\u0026rsquo;re able to remove the creation and storing of a driver instance in beforeEach and leverage the driver variable stored on this instead. We\u0026rsquo;re also able to remove the afterEach method entirely.\nIf we save our files and run our tests (e.g., mocha from the command-line) they should work just like before.\nPart 2: Base URL It\u0026rsquo;s a given that we\u0026rsquo;ll need to run our tests against different environments (e.g., localhost, test, staging, production, etc.). So let\u0026rsquo;s make it so we can specify a different base URL for our tests at runtime.\nFirst, let\u0026rsquo;s create a file called config.js in the lib directory.\n├── lib │ ├── config.js │ └── DriverFactory.js ├── package.json ├── pages │ ├── BasePage.js │ ├── DynamicLoadingPage.js │ └── LoginPage.js ├── test │ ├── DynamicLoadingTest.js │ ├── LoginTest.js │ ├── mocha.opts │ └── spec_helper.js └── vendor └── geckodriver In it we\u0026rsquo;ll specify a variable for baseUrl that will grab and store an environment. If one is not provided then a sensible default will be used.\n// filename: lib/config.js module.exports = { baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com' }; Now let\u0026rsquo;s update the visit method in the base page object to use this config object.\n// filename: pages/BasePage.js const config = require('./config') // ... async function visit(url) { if (url.startsWith('http')) { await this.driver.get(url) } else { await this.driver.get(config.baseUrl + url) } } In visit there could be a case where we\u0026rsquo;ll want to navigate to a full URL so to be safe we\u0026rsquo;ve added a conditional check of the url parameter to see if a full URL was passed in. If so, we visit it. If not, config.baseUrl is combined with the URL path passed in as an argument to create the full URL (e.g., config.baseUrl + url) and visit it.\nNow all we need to do is update our page objects so they\u0026rsquo;re no longer using hard-coded URLs.\n// filename: pages/LoginPage.js // ... async load() { await this.visit('/login') if (!(await this.isDisplayed(LOGIN_FORM, 1000))) throw new Error('Login form not loaded') } // ... // filename: pages/DynamicLoadingPage.js // ... async loadExample(exampleNumber) { await this.visit('/dynamic_loading/' + exampleNumber) await this.click(START_BUTTON) } // ... Outro Now when running our tests, we can specify a different base URL by providing some extra information at run-time (e.g., BASE_URL=url mocha). We\u0026rsquo;re also in a better position now with our setup and teardown abstracted into a central location.\nNow we can easily extend our test framework to run our tests on other browsers.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-11-running-a-different-browser-locally/","tags":["Selenium","Javascript","Node.js"],"title":"Running A Different Browser Locally | Selenium webdriver nodejs"},{"categories":["Coding"],"contents":"SOLID is an acronym created by Michael Feathers from the principles of object-oriented programming identified by Robert C. Martin (Uncle Bob).\nThese principles aim to make the code more readable, easy to maintain, extensible, reusable and without repetition.\nSingle Responsibility Principle The Single Responsibility Principle says that a class must have only one reason to change and only one responsibility.\nBad example public sealed class Customer { public int Id { get; set; } public string Name { get; set; } public bool Active { get; set; } public void Activate() { Active = true; } public void Inactivate() { Active = false; } public void Insert() { /// Implementation for ADDING to DATABASE } public void Delete() { /// Implementation for DELETING to DATABASE } } The code is incorrect because it has two responsibilities, business rules and database persistence.\nGood example public sealed class Customer { public int Id { get; set; } public string Name { get; set; } public bool Active { get; set; } public void Activate() { Active = true; } public void Inactivate() { Active = false; } } public sealed class CustomerRepository { public void Insert(Customer customer) { /// Implementation for ADDING to DATABASE } public void Delete(Customer customer) { /// Implementation for DELETING to DATABASE } } The code is correct because the responsibilities have been split, each class has only one reason to change.\nOpen Closed Principle The Open Closed Principle says the code must be open for extension and closed for modification.\nBad example public enum PaymentMethod { Cash = 1, CreditCard = 2, DebitCard = 3 } public class PaymentService { public void Pay(PaymentMethod paymentMethod) { /// Implementation if (paymentMethod == PaymentMethod.Cash) { /// Implementation } else if (paymentMethod == PaymentMethod.CreditCard) { /// Implementation } else if (paymentMethod == PaymentMethod.DebitCard) { /// Implementation } /// Implementation } } The code is incorrect because it is open for modification. If a new payment method is added, the class has to be changed.\nGood example public interface IPaymentMethod { void Pay(); } public sealed class Cash : IPaymentMethod { public void Pay() { /// Implementation } } public sealed class CreditCard : IPaymentMethod { public void Pay() { /// Implementation } } public sealed class DebitCard : IPaymentMethod { public void Pay() { /// Implementation } } public class PaymentService { private readonly IPaymentMethod _paymentMethod; public PaymentService(IPaymentMethod paymentMethod) { _paymentMethod = paymentMethod; } public void Pay() { /// Implementation _paymentMethod.Pay(); /// Implementation } } The code is correct because if a new payment method is added the class is not modified.\nLiskov Substitution Principle The Liskov Substitution Principle says that derived classes must be substitutable for their base classes.\nBad example public class Cat { public virtual string GetName() { return nameof(Cat); } public void Move() { /// Implementation } public void Eat() { /// Implementation } } public class Dog : Cat { public override string GetName() { return nameof(Dog); } } public static class Program { public static void Main() { Cat cat = new Dog(); cat.GetName(); } } The code is incorrect because the Dog class is inheriting from the Cat class only because it has similar behaviors. Executing \u0026ldquo;cat.GetName()\u0026rdquo; will display \u0026ldquo;Dog\u0026rdquo;.\nGood example public abstract class Animal { public abstract string GetName(); public virtual void Move() { /// Implementation } public void Eat() { /// Implementation } } public sealed class Cat : Animal { public override string GetName() { return nameof(Cat); } } public sealed class Dog : Animal { public override string GetName() { return nameof(Dog); } public override void Move() { /// Implementation } } public static class Program { public static void Main() { var animals = new List\u0026lt;Animal\u0026gt; { new Cat(), new Dog() }; foreach (var animal in animals) { animal.GetName(); animal.Move(); animal.Eat(); } } } The code is correct because the Cat and Dog classes can be replaced by the Animal class without having unexpected behaviors.\nInterface Segregation Principle The Interface Segregation Principle says that many specific interfaces are better than a single interface.\nBad example public interface IBase { void ChangeId(int id); void ChangeAddress(string address); void ChangePrice(decimal price); } public sealed class Customer : IBase { public int Id { get; set; } public string Name { get; set; } public string Address { get; set; } public void ChangeId(int id) { Id = id; } public void ChangeAddress(string address) { Address = address; } public void ChangePrice(decimal price) { throw new NotImplementedException(); } } public sealed class Product : IBase { public int Id { get; set; } public string Description { get; set; } public decimal Price { get; set; } public void ChangeId(int id) { Id = id; } public void ChangePrice(decimal price) { Price = price; } public void ChangeAddress(string address) { throw new NotImplementedException(); } } The code is incorrect because the Customer class is required to have the ChangePrice method, and the Product class is required to have the ChangeAddress method, only because they implement the same interface.\nGood example public interface IBase { void ChangeId(int id); } public interface ICustomer : IBase { void ChangeAddress(string address); } public interface IProduct : IBase { void ChangePrice(decimal price); } public sealed class Customer : ICustomer { public int Id { get; set; } public string Name { get; set; } public string Address { get; set; } public void ChangeId(int id) { Id = id; } public void ChangeAddress(string address) { Address = address; } } public sealed class Product : IProduct { public int Id { get; set; } public string Description { get; set; } public decimal Price { get; set; } public void ChangeId(int id) { Id = id; } public void ChangePrice(decimal price) { Price = price; } } The code is correct because the generic interface has been split into specific interfaces. The classes do not implement methods that are not part of your business logic.\nDependency Inversion Principle The Dependency Inversion Principle says to depend on abstraction, not implementation.\nBad example public sealed class Customer { public int Id { get; set; } public string Name { get; set; } } public sealed class CustomerRepository { public CustomerRepository(string connectionString) { /// Implementation } public void Add(Customer customer) { /// Implementation } } public sealed class CustomerService { private readonly CustomerRepository _customerRepository = new CustomerRepository(\u0026quot;ConnectionString\u0026quot;); public void Add(Customer customer) { _customerRepository.Add(customer); } } The code is incorrect because the CustomerService class depends on the CustomerRepository class and also knows how to instantiate it.\nGood example public sealed class Customer { public int Id { get; set; } public string Name { get; set; } } public interface ICustomerRepository { void Add(Customer customer); } public sealed class CustomerRepository : ICustomerRepository { public CustomerRepository(string connectionString) { /// Implementation } public void Add(Customer customer) { /// Implementation } } public sealed class CustomerService { private readonly ICustomerRepository _customerRepository; public CustomerService(ICustomerRepository customerRepository) { _customerRepository = customerRepository; } public void Add(Customer customer) { _customerRepository.Add(customer); } } The code is correct** because the CustomerService class depends only on the ICustomerRepository interface. It does not know the implementation or how to instantiate it.\n","permalink":"https://codingactions.com/solid-principles-simplified/","tags":["Dotnet","Design Patterns"],"title":"SOLID Principles Simplified with Examples"},{"categories":["Automated Testing"],"contents":"This post (Prepping For Use) is part of a series about Selenium WebDriver with Node.js .\nNow that we have some tests and page objects, we\u0026rsquo;ll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.\nPart 1: Global Setup \u0026amp; Teardown We\u0026rsquo;ll start by pulling the Selenium setup and teardown out of our tests and into a central location.\nWe\u0026rsquo;ll create three things. A class that will contain the creation and destruction of our Selenium instances (a.k.a. a Driver Factory), a helper that all tests will pull from, and an option file Mocha uses to store commonly used command-line arguments.\nIn the lib directory we\u0026rsquo;ll create a new file called DriverFactory.js, and in the test directory we\u0026rsquo;ll create files called spec_helper.js and mocha.opts.\n├── lib │ └── DriverFactory.js ├── package.json ├── pages │ ├── BasePage.js │ ├── DynamicLoadingPage.js │ └── LoginPage.js ├── test │ ├── DynamicLoadingTest.js │ ├── LoginTest.js │ ├── mocha.opts │ └── spec_helper.js └── vendor └── geckodriver Here are the initial contents of the Driver Factory.\n// filename: lib/DriverFactory.js const path = require('path') const { Builder } = require('selenium-webdriver') class DriverFactory { async build() { process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor') this.driver = await new Builder().forBrowser('firefox').build() } async quit() { await this.driver.quit() } } module.exports = DriverFactory After requiring our requisite libraries, we declare a class along with two methods \u0026ndash; build, and quit. build is responsible for creating an instance of Selenium and quit is responsible for destroying the Selenium instance.\nThe class ends with module.exports, just like in previous classes we\u0026rsquo;ve created.\nNow to update our mocha.opts file. It\u0026rsquo;s a small change that will help us clean up the hard-coded timeout that we\u0026rsquo;ve needed to specify in each test.\n// filename: test/mocha.opts -t 60000 Now let\u0026rsquo;s put everything to use in our spec helper.\n// filename: test/spec_helper.js const DriverFactory = require('../lib/DriverFactory') const driverFactory = new DriverFactory() beforeEach(async function() { await driverFactory.build() this.driver = driverFactory.driver }) afterEach(async function() { await driverFactory.quit() }) In Mocha, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as root-level hooks.\nAt the top of the spec helper we require the Driver Factory and create a new instance of it, storing it in a variable.\nIn beforeEach we create a driver instance and store it in a variable on this (which will make it accessible to the test).\nIn afterEach we call the quit method in the Driver Factory to destroy the Selenium instance.\nNow to update our tests.\n// filename: test/LoginTest.js require('./spec_helper') const assert = require('assert') const LoginPage = require('../pages/LoginPage') describe('Login', function() { let login beforeEach(async function() { login = new LoginPage(this.driver) await login.load() }) it('with valid credentials', async function() { await login.authenticate('tomsmith', 'SuperSecretPassword!') assert(await login.successMessagePresent(), 'Success message not displayed') }) it('with invalid credentials', async function() { await login.authenticate('tomsmith', 'bad password') assert(await login.failureMessagePresent(), 'Failure message not displayed') }) }) // filename: test/DynamicLoadingTest.js require('./spec_helper') const assert = require('assert') const DynamicLoadingPage = require('../pages/DynamicLoadingPage') describe('Dynamic Loading', function() { let dynamicLoading beforeEach(async function() { dynamicLoading = new DynamicLoadingPage(this.driver) }) it('hidden element', async function() { await dynamicLoading.loadExample('1') assert( await dynamicLoading.isFinishTextPresent(), true, 'Finish text not displayed' ) }) it('rendered element', async function() { await dynamicLoading.loadExample('2') assert( await dynamicLoading.isFinishTextPresent(), true, 'Finish text not displayed' ) }) }) In order to use the spec helper we just need to require it.\nThen we\u0026rsquo;re able to remove the creation and storing of a driver instance in beforeEach and leverage the driver variable stored on this instead. We\u0026rsquo;re also able to remove the afterEach method entirely.\nIf we save our files and run our tests (e.g., mocha from the command-line) they should work just like before.\nPart 2: Base URL It\u0026rsquo;s a given that we\u0026rsquo;ll need to run our tests against different environments (e.g., localhost, test, staging, production, etc.). So let\u0026rsquo;s make it so we can specify a different base URL for our tests at runtime.\nFirst, let\u0026rsquo;s create a file called config.js in the lib directory.\n├── lib │ ├── config.js │ └── DriverFactory.js ├── package.json ├── pages │ ├── BasePage.js │ ├── DynamicLoadingPage.js │ └── LoginPage.js ├── test │ ├── DynamicLoadingTest.js │ ├── LoginTest.js │ ├── mocha.opts │ └── spec_helper.js └── vendor └── geckodriver In it we\u0026rsquo;ll specify a variable for baseUrl that will grab and store an environment. If one is not provided then a sensible default will be used.\n// filename: lib/config.js module.exports = { baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com' }; Now let\u0026rsquo;s update the visit method in the base page object to use this config object.\n// filename: pages/BasePage.js const config = require('./config') // ... async function visit(url) { if (url.startsWith('http')) { await this.driver.get(url) } else { await this.driver.get(config.baseUrl + url) } } In visit there could be a case where we\u0026rsquo;ll want to navigate to a full URL so to be safe we\u0026rsquo;ve added a conditional check of the url parameter to see if a full URL was passed in. If so, we visit it. If not, config.baseUrl is combined with the URL path passed in as an argument to create the full URL (e.g., config.baseUrl + url) and visit it.\nNow all we need to do is update our page objects so they\u0026rsquo;re no longer using hard-coded URLs.\n// filename: pages/LoginPage.js // ... async load() { await this.visit('/login') if (!(await this.isDisplayed(LOGIN_FORM, 1000))) throw new Error('Login form not loaded') } // ... // filename: pages/DynamicLoadingPage.js // ... async loadExample(exampleNumber) { await this.visit('/dynamic_loading/' + exampleNumber) await this.click(START_BUTTON) } // ... Outro Now when running our tests, we can specify a different base URL by providing some extra information at run-time (e.g., BASE_URL=url mocha). We\u0026rsquo;re also in a better position now with our setup and teardown abstracted into a central location.\nNow we can easily extend our test framework to run our tests on other browsers.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-10-prepping-for-use/","tags":["Selenium","Javascript","Node.js"],"title":"Prepping For Use | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Writing Really Re-usable Test Code) is part of a series about Selenium WebDriver with Node.js .\nIn the previous chapter we stepped through creating a simple page object to capture the behavior of the page we were interacting with. While this was a good start, there\u0026rsquo;s more we can do.\nAs our test suite grows and we add more page objects we will start to see common behavior that we will want to use over and over again throughout our suite. If we leave this unchecked we will end up with duplicative code which will slowly make our page objects harder to maintain.\nRight now we are using Selenium actions directly in our page object. While on the face of it this may seem fine, it has some long term impacts, like:\nslower page object creation due to the lack of a simple Domain Specific Language (DSL) test maintenance issues if the Selenium API changes the inability to swap out the driver for your tests (e.g., mobile, REST, etc.) With a facade layer we can easily side step these concerns by abstracting our common actions into a central place and leveraging it in our page objects.\nAn Example Let\u0026rsquo;s step through an example with our login page object.\nPart 1: Create The Facade Layer First let\u0026rsquo;s add a new file called BasePage.js in pages directory.\n├── package.json ├── pages │ ├── BasePage.js │ └── LoginPage.js └── test └── LoginTest.js └── vendor └── geckodriver Next let\u0026rsquo;s populate the file.\n// filename: pages/BasePage.js class BasePage { constructor(driver) { this.driver = driver } async visit(url) { await this.driver.get(url) } find(locator) { return this.driver.findElement(locator) } async click(locator) { await this.find(locator).click() } async type(locator, inputText) { await this.find(locator).sendKeys(inputText) } async isDisplayed(locator) { return await find(locator).isDisplayed() } } module.exports = BasePage In this module we declare a BasePage class along with methods for all of the common behavior we use with Selenium (e.g., visit, find, click, type, and isDisplayed). We also have a constructor that enables us to pass in and store an instance of the driver, so we don\u0026rsquo;t have to explicitly pass it to the methods whenever we call them.\nNow let\u0026rsquo;s update our login page object to leverage this facade.\n// filename: pages/LoginPage.js const BasePage = require('./BasePage') const LOGIN_FORM = { id: 'login' } const USERNAME_INPUT = { id: 'username' } const PASSWORD_INPUT = { id: 'password' } const SUBMIT_BUTTON = { css: 'button' } const SUCCESS_MESSAGE = { css: '.flash.success' } const FAILURE_MESSAGE = { css: '.flash.error' } class LoginPage extends BasePage { constructor(driver) { super(driver) } async load() { await this.visit('http://the-internet.herokuapp.com/login') if (await !this.isDisplayed(LOGIN_FORM)) throw new Error('Login form not loaded') } async authenticate(username, password) { await this.type(USERNAME_INPUT, username) await this.type(PASSWORD_INPUT, password) await this.click(SUBMIT_BUTTON) } successMessagePresent() { return this.isDisplayed(SUCCESS_MESSAGE) } failureMessagePresent() { return this.isDisplayed(FAILURE_MESSAGE) } } module.exports = LoginPage A few things have changed in our Login page object. We\u0026rsquo;ve imported the base page class we want to use, established inheritance between the two classes, and we\u0026rsquo;ve swapped out all of our Selenium commands with calls to the methods in the base page object (e.g., this.visit, this.type, this.click, etc.).\nTo establish inheritance we used the extends keyword when declaring the class (e.g., class LoginPage extends Page {) and called super from the constructor (e.g., super(driver)). This passes the instance of Selenium to the base page object, and makes all of the base page object\u0026rsquo;s methods available to our login page object (though this.).\nIf we save everything and run our tests they will run and pass just like before. But now our page objects are more readable, simpler to write, and easier to maintain and extend.\nPart 2: Add Some Error Handling Remember in the previous chapter when we ran into an error with Selenium when we looked for an element that wasn\u0026rsquo;t on the page? Let\u0026rsquo;s address that now.\nTo recap \u0026ndash; here\u0026rsquo;s the error message we saw:\nNoSuchElementError: Unable to locate element: {\u0026quot;method\u0026quot;:\u0026quot;css selector\u0026quot;,\u0026quot;selector\u0026quot;:\u0026quot;.flash.success\u0026quot;} The important thing to note is the name of the exception Selenium offered up \u0026ndash; NoSuchElementError. Let\u0026rsquo;s modify the isDisplayed method in our base page object to handle it.\n// filename: pages/BasePage.js // ... async isDisplayed(locator) { try { return await this.find(locator).isDisplayed() } catch (error) { return false } } // ... Thanks to async / await we can reliabily use a try / catch block to account for the NoSuchElementError and return false instead.\nNow let\u0026rsquo;s revisit our 'with invalid credentials' login test and alter it so it checks to see if the success message is not present to make sure things work as we expect.\n// filename: test/LoginTest.js // ... it('with invalid credentials', async function() { await login.authenticate('tomsmith', 'bad password') assert(!(await login.successMessagePresent()), 'Success message displayed') // ... }) }) When we save our changes and run this test it will run and pass without throwing an exception this time. Feel free to keep the test as-is, or change it back to what it was before.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-9-writing-really-re-usable-test-code/","tags":["Selenium","Javascript","Node.js"],"title":"Writing Really Re-usable Test Code | Selenium webdriver nodejs"},{"categories":["Coding"],"contents":"The Problem An IP is short for Internet Protocol. It is used to identify computers or mobile devices on the Internet. Each device connected to the Internet has an IP address.\nEver needed to get your public IP address programmatically using Node.js?\nMaybe you\u0026rsquo;re provisioning new cloud servers and need to know your IP, maybe you\u0026rsquo;re behind a corporate firewall and need to tunnel information \u0026hellip;\nWhatever the reason: sometimes having a public IP address API is useful!\nA Solution Method N°1: Using curl and child_process const { execSync } = require(\u0026quot;child_process\u0026quot;); const cmd = `curl -s http://checkip.amazonaws.com || printf \u0026quot;0.0.0.0\u0026quot;`; const pubIp = execSync(cmd).toString().trim(); console.log(`My public IP address is: ${pubIp}`); Sample output:\nOutput: My public IP address is: 30.5.3.34 Method N°2: Using Node.js http client For this example we are using the popular Axios http client, but you can use any Node.js http client.\nconst axios = require(\u0026quot;axios\u0026quot;); (async () =\u0026gt; { const url = \u0026quot;https://checkip.amazonaws.com/\u0026quot;; const response = await axios(url); console.log(`My public IP address is: ${response.data.trim()}`); })(); Sample output:\nOutput: My public IP address is: 30.5.3.34 Method N°3: Using Node.js built-in libraries dns, net or http Alternatively, you can use the dns or net built-in libraries to get your public IP address by performing a DNS lookup or connecting to a remote server, respectively. Here\u0026rsquo;s an example using the http library:\nvar http = require('http'); http.get({'host': 'api.ipify.org', 'port': 80, 'path': '/'}, function(resp) { resp.on('data', function(ip) { console.log(\u0026quot;My public IP address is: \u0026quot; + ip); }); }); Sample output:\nOutput: My public IP address is: 30.5.3.34 Alternative servers If you encounter a problem with the checkip.amazonaws.com server, you can use one of the alternative servers listed below.\nhttps://api.ipify.org https://tnx.nl/ip https://api.infoip.io/ip Free Online IPV4 and IPV6 tool You can also use our WhatIsMyIp free online to get your IP address!\n","permalink":"https://codingactions.com/how-to-get-my-public-ip-address-using-node-js/","tags":["Node.js","JavaScript"],"title":"How to get My Public IP address Using Node.js"},{"categories":["Automated Testing"],"contents":"This post (Writing Re-usable Test Code) is part of a series about Selenium WebDriver with Node.js .\nOne of the biggest challenges with Selenium tests is that they can be brittle and challenging to maintain over time. This is largely due to the fact that things in the application you\u0026rsquo;re testing change \u0026ndash; causing your tests to break.\nBut the reality of a software project is that change is a constant. So we need to account for this reality somehow in our test code in order to be successful.\nEnter Page Objects.\nA Page Objects Primer Rather than write your test code directly against your app, you can model the behavior of your application into simple objects and write your tests against them instead. That way when your app changes and your tests break, you only have to update your test code in one place to fix it.\nWith this approach we not only get the benefit of controlled chaos, we also get reusable functionality across our suite of tests and more readable tests.\nAn Example Part 1: Create A Page Object And Update Test Let\u0026rsquo;s take our login example from earlier, create a page object for it, and update our test accordingly.\nFirst we\u0026rsquo;ll need to create a new folder called pages in the root of our project (just like we did for test). In it we\u0026rsquo;ll add a LoginPage.js file. When we\u0026rsquo;re done our directory structure should look like this.\n├── package.json ├── pages │ └── LoginPage.js └── test └── LoginTest.js └── vendor └── geckodriver Here\u0026rsquo;s the code that goes with it.\n// filename: pages/LoginPage.js const USERNAME_INPUT = { id: 'username' } const PASSWORD_INPUT = { id: 'password' } const SUBMIT_BUTTON = { css: 'button' } const SUCCESS_MESSAGE = { css: '.flash.success' } class LoginPage { constructor(driver) { this.driver = driver } async load() { await this.driver.get('http://the-internet.herokuapp.com/login') } async authenticate(username, password) { await this.driver.findElement(USERNAME_INPUT).sendKeys(username) await this.driver.findElement(PASSWORD_INPUT).sendKeys(password) await this.driver.findElement(SUBMIT_BUTTON).click() } async successMessagePresent() { return await this.driver.findElement(SUCCESS_MESSAGE).isDisplayed() } } module.exports = LoginPage At the top of the file we specify some variables. These are for the locators we want to use on the page. We then declare the class by specifying its constructor (e.g., concstructor(driver) {). This block will run whenever a new instance of the class is created. In order for this class to work we need access to the Selenium driver object, so we accept it as a parameter in the constructor and store it in the a class variable (e.g., this.driver). This enables the rest of the class to use it.\nThe second method (e.g., load()) is responsible for navigating to the page. Since it\u0026rsquo;s asynchronous we can\u0026rsquo;t have this behavior happen in the constructor.\nThie third method (e.g., authenticate(username, password)) is the core functionality of the login page. It\u0026rsquo;s responsible for filling in the login form and submitting it. By accepting parameters for the username and password we\u0026rsquo;re able to make the functionality here reusable for additional tests. Also, instead of the hard-coded locators, we updated the Selenium calls with the locator variables we specified at the top of the class.\nThe last method (e.g., successMessagePresent()) is the display check from earlier that was used in our assertion. It will return a boolean result just like before.\nThe class ends with module.exports = LoginPage;. This makes it so the class gets returned as an object when it is required in our test.\nNow let\u0026rsquo;s update our test to use this page object.\n// filename: test/LoginTest.js const { Builder } = require('selenium-webdriver') const path = require('path') const assert = require('assert') const LoginPage = require('../pages/LoginPage') describe('Login', function() { this.timeout(30000) let driver let login beforeEach(async function() { const vendorDirectory = path.delimiter + path.join(__dirname, '..', 'vendor') process.env.PATH += vendorDirectory driver = await new Builder().forBrowser('firefox').build() login = new LoginPage(driver) await login.load() }) afterEach(async function() { await driver.quit() }) it('with valid credentials', async function() { await login.authenticate('tomsmith', 'SuperSecretPassword!') assert(await login.successMessagePresent(), 'Success message not displayed') }) }) Before we can use the page object we first need to require it (e.g., const LoginPage = require('../pages/LoginPage');). Then it\u0026rsquo;s a simple matter of updating our test setup to create an instance of the login page (storing it in a login variable) and updating the test method to use the page object instead.\nNow the test is more concise and readable. When you save everything and run it (e.g., mocha from the command-line), it will run and pass just like before.\nPart 2: Write Another Test Creating a page object may feel like more work than what we started with initially. But it\u0026rsquo;s well worth the effort since we\u0026rsquo;re in a much sturdier position and able to easily write follow-on tests (since the specifics of the page are abstracted away for simple reuse).\nLet\u0026rsquo;s add another test for a failed login to demonstrate.\nFirst, let\u0026rsquo;s take a look at the markup that gets rendered when we provide invalid credentials:\n\u0026lt;div id=\u0026quot;flash-messages\u0026quot; class=\u0026quot;large-12 columns\u0026quot;\u0026gt; \u0026lt;div data-alert=\u0026quot;\u0026quot; id=\u0026quot;flash\u0026quot; class=\u0026quot;flash error\u0026quot;\u0026gt; Your username is invalid! \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;close\u0026quot;\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; Here is the element we\u0026rsquo;ll want to use in our assertion.\nclass=\u0026quot;flash error\u0026quot; Let\u0026rsquo;s add a locator for this element to our page object along with a new method to perform a display check against it.\n// filename: pages/LoginPage.js // ... var SUCCESS_MESSAGE = {css: '.flash.success'}; var FAILURE_MESSAGE = {css: '.flash.error'}; // ... async failureMessagePresent() { return await this.driver.findElement(FAILURE_MESSAGE).isDisplayed() } } module.exports = LoginPage; Now we\u0026rsquo;re ready to add a test for failed login to our test/LoginTest.js file.\n// filename: test/LoginTest.js // ... it('with invalid credentials', async function() { await login.authenticate('tomsmith', 'SuperSecretPassword!') assert(await login.failureMessagePresent(), 'Failure message not displayed') }) }) If we save these changes and run our tests (e.g., mocha from the command-line) we will see two browser windows open (one after the other) testing for successful and failure login scenarios.\nWhy Checking For The Absence Of An Element Won\u0026rsquo;t Work (yet) You may be wondering why we didn\u0026rsquo;t just check to see if the success message wasn\u0026rsquo;t present in our assertion.\nassert(!(await login.successMessagePresent()), 'Success message displayed') There are two problems with this approach. First, our test will fail because Selenium errors when it looks for an element that\u0026rsquo;s not present on the page \u0026ndash; which looks like this:\nNoSuchElementError: Unable to locate element: {\u0026quot;method\u0026quot;:\u0026quot;css selector\u0026quot;,\u0026quot;selector\u0026quot;:\u0026quot;.flash.success\u0026quot;} But don\u0026rsquo;t worry, we\u0026rsquo;ll address this in the next chapter.\nSecond, the absence of a success message doesn\u0026rsquo;t necessarily indicate a failed login. The assertion we ended up with originally is more accurate.\n// filename: test/LoginTest.js // ... it('with invalid credentials', async function() { await login.authenticate('tomsmith', 'bad password') assert(await login.failureMessagePresent(), 'Failure message not displayed') }) }) Part 3: Confirm We\u0026rsquo;re In The Right Place Before we can call our page object complete, there\u0026rsquo;s one more addition we should make. We\u0026rsquo;ll want to add a check to make sure that Selenium is in the right place before proceeding, which will in turn, add some resiliency to our tests.\n// filename: pages/LoginPage.js // ... async load() { await this.driver.get('http://the-internet.herokuapp.com/login') if (!(await this.driver.findElement(LOGIN_FORM).isDisplayed())) throw new Error('Login form not loaded') } // ... In our load method of the login page we want to check to see that the login form is displayed after navigating there. If not, we will throw an exception with the message 'Login form not loaded', which will error the test before it attempts to log in (and provide this message in the output). Otherwise, the test will proceed without issue.\nWhen we save everything and run our tests they will run just like before. But now we can feel confident that the tests will only proceed if login page is in a ready state.\nOutro With Page Objects you\u0026rsquo;ll be able to easily maintain and extend your tests. But how you write your Page Objects may vary depending on your preference and experience. The example demonstrated above is a simple approach. It\u0026rsquo;s worth taking a look at the Selenium project wiki page for Page Objects here (even if its examples are only written in Java). There\u0026rsquo;s also Martin Fowler\u0026rsquo;s seminal blog post on the topic as well ( link ).\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-8-writing-re-usable-test-code/","tags":["Selenium","Javascript","Node.js"],"title":"Writing Re-usable Test Code | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Verifying Your Locators) is part of a series about Selenium WebDriver with Node.js .\nIf you\u0026rsquo;re fortunate enough to be working with unique IDs and Classes, then you\u0026rsquo;re usually all set. But when you have to handle more complex actions like traversing a page, or you need to run down odd test behavior, it can be a real challenge to verify that you have the right locators to accomplish what you want.\nInstead of the painful and tedious process of trying out various locators in your tests until you get what you\u0026rsquo;re looking for, try verifying them in the browser instead.\nA Solution Built into every major browser is the ability to verify locators from the JavaScript Console.\nSimply open the developer tools in your browser and navigate to the JavaScript Console (e.g., right-click on an element, select Inspect Element, and click into the Console tab). From here it\u0026rsquo;s a simple matter of specifying the CSS selector you want to look up by the $$('') command (e.g., $$('#username')) and hovering your mouse over what is returned in the console. The element that was found will be highlighted in the viewport.\nAn Example Let\u0026rsquo;s try to identify the locators necessary to traverse a few levels into a large set of nested divs.\n\u0026lt;!-- a snippet from http://the-internet.herokuapp.com/large --\u0026gt; \u0026lt;div id='siblings'\u0026gt; \u0026lt;div id='sibling-1.1'\u0026gt;1.1 \u0026lt;div id='sibling-1.2'\u0026gt;1.2\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-1.3'\u0026gt;1.3\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-2.1'\u0026gt;2.1 \u0026lt;div id='sibling-2.2'\u0026gt;2.2\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-2.2'\u0026gt;2.3\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-3.1'\u0026gt;3.1 \u0026lt;div id='sibling-3.2'\u0026gt;3.2\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-3.2'\u0026gt;3.3\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-3.1'\u0026gt;4.1 \u0026lt;div id='sibling-3.2'\u0026gt;4.2\u0026lt;/div\u0026gt; \u0026lt;div id='sibling-3.2'\u0026gt;4.3\u0026lt;/div\u0026gt; \u0026lt;!-- ... --\u0026gt; If we perform a findElement action using the following locator, it works.\ndriver.findElement({css: 'div#siblings \u0026gt; div:nth-of-type(1) \u0026gt; div:nth-of-type(1)'}); But if we try to go one level deeper with the same approach, it won\u0026rsquo;t work.\ndriver.findElement({css: 'div#siblings \u0026gt; div:nth-of-type(1) \u0026gt; div:nth-of-type(1) \u0026gt; div:nth-of-type(1)'}); Fortunately with our in-browser approach to verifying our locators, we can quickly discern where the issue is. Here\u0026rsquo;s what it shows us for the locators that \u0026ldquo;worked\u0026rdquo;.\nIt looks like our locators are scoping to the wrong part of the first level (1.2). But we need to reference the third part of each level (e.g., 1.3, 2.3, 3.3) in order to traverse deeper since the nested divs live under the third part of each level.\nSo if we try this locator instead, it should work.\ndriver.findElement({css: 'div#siblings \u0026gt; div:nth-of-type(1) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3)'}); We can confirm that it works before changing any test code by looking in the JavaScript Console first.\nThis should help save you time and frustration when running down tricky locators in your tests. It definitely has for me.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-7-verifying-your-locators/","tags":["Selenium","Javascript","Node.js"],"title":"Verifying Your Selenium Locators | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Writing Your First Test) is part of a series about Selenium WebDriver with Node.js .\nFundamentally, Selenium works with two pieces of information \u0026ndash; the element on a page you want to use and what you want to do with it. This one-two punch will be repeated over and over until you achieve the outcome you want in your application. At which point you will perform an assertion to confirm that the result is what you intended.\nLet\u0026rsquo;s take logging in to a website as an example. With Selenium you would:\nVisit the login page of a site Find the login form\u0026rsquo;s username field and input the username Find the login form\u0026rsquo;s password field and input the password Find the submit button and click it Selenium is able to find and interact with elements on a page by way of various locator strategies. The list includes (sorted alphabetically):\nClass CSS Selector ID Link Text Name Partial Link Text Tag Name XPath While each serves a purpose, you only need to know a few to start writing effective tests.\nHow To Find Locators The simplest way to find locators is to inspect the elements on a page. The best way to do this is from within your web browser. Fortunately, popular browsers come pre-loaded with development tools that make this simple to accomplish.\nWhen viewing the page, right-click on the element you want to interact with and click Inspect Element. This will bring up a small window with all of the markup for the page but zoomed into your highlighted selection. From here you can see if there are unique or descriptive attributes you can work with.\nHow To Find Quality Elements You want to find an element that is unique, descriptive, and unlikely to change.\nRipe candidates for this are id and class attributes. Whereas text (e.g., the text of a link) is less ideal since it is more apt to change. If the elements you are attempting to work with don\u0026rsquo;t have unique id or class attributes directly on them, look at the element that houses them (a.k.a. the parent element). Oftentimes the parent element has a unique element that you can use to start with and walk down to the child element you want to use.\nWhen you can\u0026rsquo;t find any unique elements have a conversation with your development team letting them know what you are trying to accomplish. It\u0026rsquo;s typically a trivial thing for them to add helpful semantic markup to a page to make it more testable. This is especially true when they know the use case you\u0026rsquo;re trying to automate. The alternative can be a lengthy and painful process which might yield working test code but it will be brittle and hard to maintain.\nOnce you\u0026rsquo;ve identified the target elements and attributes you\u0026rsquo;d like to use for your test, you need to craft locators using one Selenium\u0026rsquo;s strategies.\nAn Example Part 1: Find The Elements And Write The Test Here\u0026rsquo;s the markup for a standard login form (pulled from the login example on the-internet ).\n\u0026lt;form name=\u0026quot;login\u0026quot; id=\u0026quot;login\u0026quot; action=\u0026quot;/authenticate\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;large-6 small-12 columns\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;username\u0026quot;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; id=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;large-6 small-12 columns\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;password\u0026quot;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; id=\u0026quot;password\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;radius\u0026quot; type=\u0026quot;submit\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;icon-2x icon-signin\u0026quot;\u0026gt; Login\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Notice the element attributes on the form. The username input field has a unique id, as does the password input field. The submit button doesn\u0026rsquo;t, but it\u0026rsquo;s the only button on the page so we can easily find it and click it.\nLet\u0026rsquo;s put these elements to use in our first test. First we\u0026rsquo;ll need to create a new folder called test in the root of our project directory. This is a default folder that Mocha will know to look for. In it we\u0026rsquo;ll create a new test file called LoginTest.js. We\u0026rsquo;ll also create a vendor directory for third-party files and download geckodriver into it. Grab the latest release from here and unpack its contents into the vendor directory. This is a required file (known as a browser driver) in order to make Selenium work with Firefox. See Chapter 13 for more detail about browser drivers.\nNOTE: As an alternative to using the vendor directory and manually downloading browser drivers for Firefox and Chrome, you can install them through npm packages (e.g., npm install geckodriver and npm install chromedriver).\nWhen we\u0026rsquo;re done our directory structure should look like this (not including the requisite node_modules directory).\n├── package.json └── test └── LoginTest.js └── vendor └── geckodriver Here is the code we will add to the test file for our Selenium commands, locators, etc.\n// filename: test/LoginTest.js const { Builder } = require('selenium-webdriver') const path = require('path') describe('Login', function() { this.timeout(30000) let driver beforeEach(async function() { const vendorDirectory = path.delimiter + path.join(__dirname, '..', 'vendor') process.env.PATH += vendorDirectory driver = await new Builder().forBrowser('firefox').build() }) afterEach(async function() { await driver.quit() }) it('with valid credentials', async function() { await driver.get('http://the-internet.herokuapp.com/login') await driver.findElement({ id: 'username' }).sendKeys('tomsmith') await driver .findElement({ id: 'password' }) .sendKeys('SuperSecretPassword!') await driver.findElement({ css: 'button' }).click() }) }) At the top of the file we import some dependencies. One is to create and control an instance of Selenium, the other is for working with file paths.\nWe declare a test class with describe('Login', function() { and specify a timeout for Mocha in milliseconds (e.g., this.timeout(30000)). The default timeout for Mocha is 2000 milliseconds (or 2 seconds). If we don\u0026rsquo;t change it then our test will fail before the browser finishes loading.\nNext we declare a driver variable where we\u0026rsquo;ll store our instance of Selenium. We handle the setup and teardown of Selenium in beforeEach and afterEach methods. This ensures that there is a clean instance of Selenium for each test (e.g., a new instance is created before a test, and destroyed after the test completes). To create an instance of Selenium we call new Builder().forBrowser('firefox').build(); and store it in the driver variable. In order for Selenium to load an instance of Firefox we need to specify the path to the directory where the geckodriver file is. We do this by finding the path to the current working directory (e.g., _dirname, appending /vendor to it, and adding this to the execution path.\nOur test method starts with it and a helfpul name (e.g., 'with valid credentials'). In this test we\u0026rsquo;re visiting the login page by its URL (with driver.get()), finding the input fields by their ID (with driver.findElement({id: 'username'});), inputting text into them (with sendKeys), and submitting the form by clicking the submit button (e.g., driver.findElement({css: 'button'}).click()).\nIf we save this and run it (by running mocha from the command-line), it will run and pass. But there\u0026rsquo;s one thing missing \u0026ndash; an assertion. In order to find an element to write an assertion against we need to see what the markup of the page is after submitting the login form.\nPart 2: Figure Out What To Assert Here is the markup that renders on the page after logging in.\n\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;flash-messages\u0026quot; class=\u0026quot;large-12 columns\u0026quot;\u0026gt; \u0026lt;div data-alert=\u0026quot;\u0026quot; id=\u0026quot;flash\u0026quot; class=\u0026quot;flash success\u0026quot;\u0026gt; You logged into a secure area! \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;close\u0026quot;\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;content\u0026quot; class=\u0026quot;large-12 columns\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;example\u0026quot;\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;i class=\u0026quot;icon-lock\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Secure Area\u0026lt;/h2\u0026gt; \u0026lt;h4 class=\u0026quot;subheader\u0026quot;\u0026gt;Welcome to the Secure Area. When you are done click logout below.\u0026lt;/h4\u0026gt; \u0026lt;a class=\u0026quot;button secondary radius\u0026quot; href=\u0026quot;/logout\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;icon-2x icon-signout\u0026quot;\u0026gt; Logout\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; There are a couple of elements we can use for our assertion in this markup. There\u0026rsquo;s the flash message class (most appealing), the logout button (appealing), or the copy from either the h2 or the flash message (least appealing).\nSince the flash message class name is descriptive, denotes a successful login, and is less likely to change than the copy, let\u0026rsquo;s go with that.\nclass=\u0026quot;flash success\u0026quot; When we try to access an element like this (e.g., with a multi-worded class) we will need to use a CSS selector or an XPath.\nNOTE: Both CSS selectors and XPath work well, but the examples throughout this book will focus on how to use CSS selectors.\nA Quick Primer on CSS Selectors In web design CSS (Cascading Style Sheets) are used to apply styles to the markup (HTML) on a page. CSS is able to do this by declaring which bits of the markup it wants to alter through the use of selectors. Selenium operates in a similar manner but instead of changing the style of elements, it interacts with them by clicking, getting values, typing, etc.\nCSS selectors are a pretty straightforward and handy way to write locators, especially for hard to reach elements.\nFor right now, here\u0026rsquo;s what you need to know. In CSS, class names start with a dot (.). For classes with multiple words, put a dot in front of each word, and remove the space between them (e.g., .flash.success for class='flash success').\nFor a good resource on CSS Selectors I encourage you to check out Sauce Labs\u0026rsquo; write up on them .\nPart 3: Write The Assertion And Verify It Now that we have our locator, let\u0026rsquo;s add an assertion that uses it.\n// filename: test/LoginTest.js // ... var assert = require('assert'); // ... it('with valid credentials', async function() { // ... assert( await driver.findElement({ css: '.flash.success' }).isDisplayed(), 'Success message not displayed' ) }); With assert we are checking for a true boolean response from Selenium on whether or not the element is displayed (e.g., .isDisplayed()). If it\u0026rsquo;s not, we want to display a helpful failure message (e.g., Success message not displayed).\nWhen we save this and run it (e.g. mocha from the command-line) it will run and pass just like before, but now there is an assertion which will catch a failure if something is amiss.\nJust To Make Sure Just to make certain that this test is doing what we think it should, let\u0026rsquo;s change the assertion to attempt to force a failure and run it again. Just add a ! in front of the driver keyword (this will invert the boolean \u0026ndash; e.g., false becomes true, true becomes false).\nassert( await !driver.findElement({ css: '.flash.success' }).isDisplayed(), 'Success message not displayed' ) If it fails then we can feel reasonably confident that the test is doing what we expect and we can change the assertion back to normal before committing our code.\nThis trick will save you more trouble that you know. Practice it often.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-6-writing-your-first-test/","tags":["Selenium","Javascript","Node.js"],"title":"Writing Your First Test | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Anatomy Of A Good Acceptance Test) is part of a series about Selenium WebDriver with Node.js .\nIn order to write automated web tests that are easy to maintain, perform well, and are ultimately resilient there are some simple guidelines to follow:\nWrite atomic and autonomous tests Group like tests together in small batches Be descriptive Use a Test Runner Store tests in a Version Control System Atomic \u0026amp; Autonomous Tests Each test needs to be concise (e.g., testing a single feature rather than multiple features) and be capable of being run independently (e.g., sets up its own data rather than relying on a previous test to do it). Doing this may require a mental shift, discipline, and more up front effort. But it will make a dramatic impact on the quality, effectiveness, and maintainability of your tests. Especially when you get into parallel test execution.\nGrouping Tests As your test suite grows you will have numerous test files. Each one containing a grouping of tests that exercise similar functionality. These test files should be grouped together in a simple directory structure as the groupings become obvious. If you want to create a test run of disparate tests, this is something that is easy to handle when using a Test Runner (covered briefly below, and in-depth in Chapter 16).\nBeing Descriptive A test file should have a high level name that denotes what the tests within it are exercising. Each test should have an informative name (even if it is a bit verbose). Also, each test (or grouping of tests) should include some helpful metadata (e.g., tags, or categories) which can provide additional information about the test as well as enable flexible test execution (more on that in Chapter 16). This way all or part of your test suite can be run, and the results will be informative thanks to helpful naming.\nThis enables developers to run a subset of tests to exercise functionality they just modified while also enabling you to intelligently wire your test suite up to a Continuous Integration (CI) server for fast and dynamic feedback (more on CI servers in Chapter 17).\nTest Runners At the heart of every test harness is some kind of a test runner that does a lot of the heavy lifting (e.g., test execution, centralized configuration, test output, etc.). Rather than reinvent the wheel you can use one of the many test runners that exist today. With it you can bolt on third party libraries to extend its functionality if there\u0026rsquo;s something missing.\nVersion Control In order to effectively collaborate with other testers and developers on your team, your test code must live in a version control system. Look to see what your development team uses and add your code to it. Otherwise, set up one of the following:\nGitHub Git Mercurial Subversion Keep in mind that your test code can live in a separate repository from the code of the application you\u0026rsquo;re testing. Combining them may be advantageous but if all you\u0026rsquo;re doing is writing and running tests against web endpoints (which is a majority of what your Selenium tests will be doing) then leaving your test code in a separate repository is a fine way to go.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-5-anatomy-of-a-good-acceptance-test/","tags":["Selenium","Javascript","Node.js"],"title":"Anatomy Of A Good Acceptance Test | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (A Programming Primer) is part of a series about Selenium WebDriver with Node.js .\nThis section will prime you with just enough programming concepts (and how they pertain to Selenium) so you have some working knowledge and a vocabulary. This will help you more effectively comprehend what you will see throughout this book (and in your work afterwards).\nDon\u0026rsquo;t get too hung up on the details though. If something doesn\u0026rsquo;t make sense it should once we dig into the full examples in the following chapters. Consider this more of a glossary than a code school.\nInstallation Installing Node.js is pretty straight-forward. There are installer packages available for Mac and Windows operating systems on the Node.js download page . There are also binary distributions avaialble for various Linux distros ( link ).\nIf you\u0026rsquo;re running on a Mac and you want to use Homebrew , then be sure to check out this write-up from Treehouse .\nInstalling Third-Party Libraries There are over 1 million third-party libraries (a.k.a. \u0026ldquo;packages\u0026rdquo;) available for Node.js through npm . npm is the Node Package Manager program that comes bundled with Node.\nYou can search for packages from npmjs.com . You don\u0026rsquo;t need an account. Simply type into the search field at the top of the page and press Enter.\nTo install packages with it you type npm install package-name from the command-line. You can install a package globally using the -g flag. You can also auto-save the package to a local file (e.g., package.json) which explicitly states the package name and version you are using with the --save flag.\nHere is a list of the packages we will be working with in this book:\nselenium-webdriver geckodriver chromedriver mocha mocha-parallel-tests Interactive Prompt Node.js comes with an interactive prompt (a.k.a. a REPL (record-eval-print loop)).\nJust type node from the command-line. It will load a simple prompt that looks like this:\n\u0026gt; In this prompt you can type out Node.js code. It will evaluate it and return the result. As you step through this chapter it will serve as a great place to practice the commands and concepts you will see.\nWhen you\u0026rsquo;re done, just type .exit.\nChoosing A Text Editor In order to write Node.js code, you will need to use a text editor. Some popular ones are Atom , Emacs , Vim , and Sublime Text .\nThere\u0026rsquo;s also the option of going for an IDE (Integrated Development Environment) like WebStorm (it\u0026rsquo;s not free, but has a free 30-day trial) or Visual Studio Code .\nIt\u0026rsquo;s important to pick an editor that works for you and makes you productive. So if you\u0026rsquo;re new to programming and text editors then it\u0026rsquo;s probably best to go with something more intuitive like Sublime Text, or WebStorm. If you end up using WebStorm be sure to check out the documentation on using it with Mocha ( link ).\nProgramming Concepts In A Nutshell Programming can be a deep and intimidating rabbit hole if you\u0026rsquo;re new to it. But don\u0026rsquo;t worry. When it comes to automated browser testing there is only a small subset of programming that we really need to know in order to get started. Granted, the more you know, the better off you\u0026rsquo;ll be. But you don\u0026rsquo;t need to know a whole lot in order to be effective right now.\nOf all the programming concepts out there, here are the ones you\u0026rsquo;ll need to pay attention right now:\nObject Structures (Variables, Functions, Methods, and Classes) Scope Object Types (Strings, Integers, Collections, Booleans, etc.) Actions (Assertions and Conditionals) Promises Let\u0026rsquo;s step through each and how they pertain to testing with Selenium.\nObject Structures Variables\nVariables are places to store and retrieve values of various types (e.g., Strings, Integers, etc. \u0026ndash; more on these later). Variables are created and then referenced by their name.\nA variable name:\nis prepended with the word let, or const can be one or more words in length starts with a letter is not case sensitive should not be a keyword or reserved word in JavaScript Since variable names are not case sensitive there are various ways you can write them (e.g., camelCase, PascalCase, snake_case, kebab-case). The general guidance across various style guides is to use camelCase.\nYou can store things in variables by using an equals sign (=) after their name. In Node.js, a variable takes on the type of the value you store in it (more on object types later).\n\u0026gt; let exampleVariable = \u0026quot;42\u0026quot;; \u0026gt; typeof(exampleVariable) // outputs: 'string' \u0026gt; exampleVariable = 42; \u0026gt; typeof(exampleVariable); // outputs: 'number' NOTE: let is used to declare a variable that can change, whereas const (short for \u0026ldquo;constant\u0026rdquo;) is used to declare a variable that will not change.\nIn Selenium, a common example of a variable is when we need to store an element (or the value from an element) in the beginning of a test to be referenced later. For example, getting a page\u0026rsquo;s title.\nconst pageTitle = driver.getTitle(); NOTE: driver is the variable we will use to interact with Selenium throughout the book. More on that later.\nFunctions\nFunctions are a way to group behavior together for easy reuse.\nThey can be specified and called on their own (e.g., they don\u0026rsquo;t need to be part of a class \u0026ndash; more on classes soon).\nWhen it comes to naming, they follow the same rules as variables. However, function names tend to be a verb (since they denote some kind of an action to be performed), and the contents of them are wrapped in opening and closing brackets (e.g., {}).\nFunctions can start either with the function keyword, or as an anonymous function (e.g., () =\u0026gt; { }).\nfunction doSomething() { // your code // goes here }; doSomething(); We can specify arguments we want to pass into a function when calling it.\nHere\u0026rsquo;s an example.\n\u0026gt; function say(message) { ... console.log(message); ... }; \u0026gt; say('Hello World!'); // outputs: Hello World! We can also specify a default value to use if no argument is provided.\n\u0026gt; function say(message = 'Hello World!') { ... console.log(message); ... }; \u0026gt; say(); // outputs: Hello World! \u0026gt; say('something else'); // outputs: something else We\u0026rsquo;ll see functions used occasionally throughout the book. Most notably in the setup and teardown for the tests.\nafterEach(async function() { const testPassed = this.currentTest.state === 'passed' await driverFactory.quit(testPassed) }) Methods\nMethods are functions that exist as part of an object (e.g., a class).\nThey can be specified as part of a class, don\u0026rsquo;t require any special keywords, and follow the same naming conventions as functions.\nClasses\nClasses are a useful way to represent a concept that will be used more than once. They can contain variables and methods. They are useful when there is some underlying data (or state) that can change that you need to keep track of.\nClass names:\nStarts with the class keyword followed by the name you want the name needs to start with a capital letter should be PascalCase for multiple words (e.g., ExampleClass) should be descriptive (e.g., a noun, whereas functions would be a verb) You first have to define the class. Then you specify variables and methods for it. Once defined, you need to create an instance of it (a.k.a. instantiation). Once you have an instance of it you can access the methods within it to trigger the behavior in them.\n\u0026gt; class Messenger { ...say(message){ ...console.log(message); ...} ... } \u0026gt; const messenger = new Messenger(); \u0026gt; messenger.say('This is an instance of a class'); // outputs: This is an instance of a class An example of a class we\u0026rsquo;ll see later in the book is storing information for how to interact with a web page \u0026ndash; also known as a page object. In it we\u0026rsquo;ll store the locators for elements on the page we want to interact with in variables, and the behavior we intend to use on those variables in methods.\nconst LOGIN_FORM = {id: \u0026quot;login\u0026quot;}; const USERNAME_INPUT = {id: \u0026quot;username\u0026quot;}; const PASSWORD_INPUT = {id: \u0026quot;password\u0026quot;}; class Login { authenticate(username, password) { // ... } Scope Now that we have our different object structures it\u0026rsquo;s worth briefly covering how they can and cannot access one another. The easiest way to do this is by discussing the different types of variables you are likely to run into.\nLocal Variables Local variables enable you to store and retrieve values from within a confined area (this is no different than what was described in the variables section earlier). A variable that was declared within a function or a method is a classic example of this. It is useful within the area it was declared, but inaccessible outside of it.\nClass Variables Variables declared as a class property will enable you to store and retrieve them through the entire class (e.g., in all of its methods).\nA common example you will see throughout the book is the usage of locators in page objects. These variables represent pieces of a web page we want to interact with. By storing them as broadly scoped variables we will be able to use them throughout an entire page object (e.g., class).\nConstants Variables that are fully capitalized and separated by underscores (e.g., _ if more than one word) are called constants. They are variables that won\u0026rsquo;t change. They are commonly used to locator variables within page objects.\nEnvironment Variables Environment variables are a way to pass information into our test code from outside of it at run-time. They are also another way to make a value globally accessible (e.g., across an entire program, or set of programs). They can be set and retrieved from within your code by:\nusing the process.env lookup function specifying the environment variable name with it Environment variables are often used to retrieve configuration values that could change when running your tests. A great example of this is which browser to run the tests against.\nmodule.exports = { browser: process.env.BROWSER || 'firefox' }; Types of Objects Strings\nStrings are alpha-numeric characters (e.g., letters, numbers, and most special characters) surrounded by either single (') or double (\u0026quot;) quotes.\nYou\u0026rsquo;ll run into Strings when working with copy on a page (e.g., pulling a page\u0026rsquo;s URL, title, or h1 tag to determine if your test is in the right place before proceeding).\nNumbers\nIf you have a test that needs to pull some values from a page and add/subtract/multiply/divide them, then this will come in handy. Although you may need to convert the values from a String to an Number first. But don\u0026rsquo;t sweat it, this is a trivial thing to do in JavaScript.\nNumber(\u0026quot;42\u0026quot;) // outputs: 42 Collections\nCollections enable you to gather a set of data for later use. In JavaScript there are two common collection types \u0026ndash; arrays and objects. The one we\u0026rsquo;ll want to pay attention to is objects.\nObjects are an unordered set of data stored in key/value pairs. The keys are unique and are used to look up data in the object.\n\u0026gt; const example = {tomato: 'tomahto', potato: 'potahto'} \u0026gt; example.tomato // outputs: 'tomahto' \u0026gt; example.potato // outputs: 'potahto' You\u0026rsquo;ll end up working with objects in page objects to store and retrieve a page\u0026rsquo;s locators.\nvar LOGIN_FORM = {id: 'login'}; var USERNAME_INPUT = {id: 'username'}; var PASSWORD_INPUT = {id: 'password'}; var SUBMIT_BUTTON = {css: 'button'}; Booleans\nBooleans are true or false values that get returned when asking a question of your code. They are what enable us to complete assertions.\nThere are numerous ways to ask these questions. Some involve various comparison operators (e.g., ==, ===, !=, \u0026lt;, \u0026gt;). The response of which is true or false.\n\u0026gt; 2+2 === 4 // outputs: true Selenium also has commands that return a boolean result when we ask questions of the page we\u0026rsquo;re testing.\nelement.isDisplayed(); // returns true if the element is on the page and visible Actions Assertions\nWith booleans we can perform assertions.\nAn assertion is used to check the that the actual result of something matches what you expected. This will result in either a passing or a failing test.\nTo leverage assertions we will need to use an assertion library (e.g., the one built into Node.js or any of the assertion libraries Mocha supports ). For the examples in this book we will be using the assertion library that comes with Node.js.\n\u0026gt; const assert = require('assert'); \u0026gt; assert.equal(2+2, 5, 'incorrect') // outputs: AssertionError: incorrect Conditionals\nConditionals work with booleans as well. They enable you to execute different code paths based on their values.\nThe most common conditionals in JavaScript are if, else if, and else statements.\nconst number = 10; if (number \u0026gt; 10) { console.log('The number is greater than 10'); } else if (number \u0026lt; 10) { console.log('The number is less than 10'); } else if (number === 10) { consle.log('The number is 10'); } else { console.log('I don't know what the number is.'); } // outputs: The number is 10 You\u0026rsquo;ll end up using conditionals in your test setup code to determine which browser to load based on a configuration value. Or whether or not to run your tests locally or somewhere else.\n} else if (config.host === 'localhost') { builder = new webdriver.Builder().forBrowser(config.browser); // ... More on that in chapters 13 and 14.\nPromises Test execution with Selenium is a fundamentally synchronous activity (e.g., visiting a page, typing text input a field, submitting the form, and waiting for the response). But JavaScript execution is inherently asynchronous, meaning that it will not wait for a command to finish executing before proceeding onto the next one.\nTo account for this we enlist the help of a Promise.\nPromises can take an asyncronous command and make our test code wait for it to complete. Thankfully, built into the Node.js there is now syntactic sugar to make working with promises very straigtforward. Through the user of the async and await keywords, we get all the benefit of promises with very little effort.\nWe\u0026rsquo;ll see these keywords often in our Selenium test code, as they are fundamental to most of the commands we\u0026rsquo;ll be using on a regular basis.\nasync authenticate(username, password) { await driver.findElement({id: 'username'}).sendKeys('tomssmith'); // ... } Additional Resources Here are some additional resources that can help you continue your JavaScript/Node.js learning journey.\ncodecademy JavaScript course Node.js Tutorals for Beginners (videos) NodeSchool JavaScript: The Good Parts (book) ","permalink":"https://codingactions.com/selenium-with-nodejs-part-4-a-programming-primer/","tags":["Selenium","Javascript","Node.js"],"title":"A Programming Primer | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Picking A Language) is part of a series about Selenium WebDriver with Node.js .\nIn order to work well with Selenium you need to choose a programming language to write your automated acceptance tests in. Conventional wisdom will tell you to choose the same language that the application is written in. That way if you get stuck you can ask the developers on your team for help. But if you\u0026rsquo;re not proficient in this language (or new to programming), then your progress will be slow and you\u0026rsquo;ll likely end up asking for more of a developer\u0026rsquo;s help than they have time for \u0026ndash; hindering your automation efforts and setting you up for failure.\nA great way to determine which language to go with is to answer one simple question: Who will own the automated tests?\nThe answer to this, and the discussion that unfolds from it, will help you more effectively choose a programming language.\nWhat To Do With The Answer If you\u0026rsquo;re a tester (or a team of testers) and you will be building and maintaining the test automation, then it\u0026rsquo;s best to consider what languages you (and your team) already have experience with, or are interested in working with. Since your Selenium tests don\u0026rsquo;t need to be written in the same language as the application you are testing, have a discussion with your team to see what interests them and go from there.\nIf you\u0026rsquo;re a developer who is working on the application and just looking to add automated acceptance testing to the mix, then it makes sense to continue with the same language.\nSome Additional Food For Thought As your suite of tests grows you will find the need to add functionality to make things easier to use, run faster, offer better reporting, etc. When this happens you will effectively be doing two jobs; no longer just writing automated tests but also building and maintaining a framework (a.k.a. a test harness).\nAs you\u0026rsquo;re considering which language to go with consider what open source frameworks already exist for the languages you are considering. Going with one can save you a lot of time and give you a host of functionality out of the box that you would otherwise have to create yourself \u0026ndash; and they\u0026rsquo;re FREE.\nOutro Choosing a programming language for automated testing is not a decision that should be taken lightly. If you\u0026rsquo;re just starting out then considering and discussing these things will help position you for long term success.\nWith all that being said, the rest of this book will show you how to build your own test harness (in addition to writing well factored tests) in JavaScript with Node.js , Mocha , and the officially supported Selenium JavaScript bindings .\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-3-picking-a-language/","tags":["Selenium","Javascript","Node.js"],"title":"Picking A Language (Javascript)| Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Defining A Test Strategy) is part of a series about Selenium WebDriver with Node.js .\nA great way to increase your chances of success with automated web testing is to first map out a testing strategy. The best way to do it is to answer these four questions:\nHow does your business make money? What features in your application are being used? What browsers are your users using? What things have broken in the application before? NOTE: For organizations that don\u0026rsquo;t deal directly in dollars and cents (e.g., non-profits, federal agencies, etc.) you should focus on how the application generates value for the end user and the organization.\nAfter answering these questions you will have an understanding of the functionality and browsers that matter for the application you\u0026rsquo;re testing. This will help you focus your efforts on the things that matter most.\nThis strategy works best for applications with existing functionality and does not speak directly to testing new functionality that\u0026rsquo;s being actively developed. That\u0026rsquo;s not to say that the two couldn\u0026rsquo;t co-exist. It largely depends on your available resources and pace of development. But in order to reach high quality at speed, you first have to go slow.\nWhat To Do With The Answers After answering these questions you should end up with a prioritized punch list (a.k.a., backlog) of test automation tasks that you can work off of and track progress against.\nQuestion 1: Money/Value Every company\u0026rsquo;s application makes money (or generates value) through core functionality that is defined by a series of increasingly-valuable user interactions \u0026ndash; a.k.a. a \u0026ldquo;funnel\u0026rdquo;. Your answers to this question will help you determine what your funnel is.\nThese items will be your highest priority for automation. Start an automation backlog to keep track of them.\nQuestion 2: Usage Data Odds are your application offers a robust set of functionality well beyond your funnel. Your answers to this question will help highlight what it is. And if you\u0026rsquo;re basing these answers on usage data (e.g., Google Analytics, etc.), then it will be broken down from highly used to lightly used.\nTack these items onto your automation backlog (below the items from question #1) based on their frequency of use.\nQuestion 3: Browsers Now that you know what functionality is business critical and widely adopted by your users, you need to determine what browsers to focus your automated web testing efforts on. Your usage data will tell you this as well. It will help you determine which browsers you can reasonably avoid testing in (e.g., based on non-existent or low usage numbers).\nNote the top 2 (or 3 depending on your numbers), but focus on the top 1 for now. This is the browser you will start using for automation.\nQuestion 4: Risky Bits To round out the strategy it is also best to think about what things have broken in the application before. To answer this question it\u0026rsquo;s best to check your defect/bug tracker (if you have one) and to ask your team. What you end up with may read like a laundry list of browser specific issues or functionality that has been flaky or forgotten about in the past. But it\u0026rsquo;s all useful information.\nBe sure to check this list against your automation backlog. If something\u0026rsquo;s not there, add it to the bottom of the backlog. If it is there, make a note in the backlog item that it has been an issue in the past.\nIf the issue has happened numerous times and has the potential to occur again, move the item up in the backlog. And if issues keep cropping up that are related to a specific browser, compare this browser to your short list of browsers from question #3. If it\u0026rsquo;s a browser that\u0026rsquo;s not in your list but it\u0026rsquo;s still important (e.g., a small pocket of influential users), track it on the backlog, but put it at the bottom.\nNow You Are Ready Having answered these questions, you should now have a prioritized backlog of critical business functionality, a short list of browsers to focus on, and an understanding of the risky parts of your application to watch out for. With it, you\u0026rsquo;re on the right track \u0026ndash; focusing on things that matter for your business and its users.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-2-defining-a-test-strategy/","tags":["Selenium","Javascript","Node.js"],"title":"Defining A Test Strategy | Selenium webdriver nodejs"},{"categories":["Automated Testing"],"contents":"This post (Selenium In A Nutshell) is part of a series about Selenium WebDriver with Node.js .\nSelenium is a software robot sent from the future to help us test web applications. But keep in mind that it\u0026rsquo;s not one of those fancy shape-shifting robots than can run really fast. It\u0026rsquo;s more like one of those really strong robots that\u0026rsquo;s not very fast and is best suited for accomplishing a certain objective.\nThat is to say Selenium is really good at a specific set of things. If you know what those are and stick to them then you can easily write reliable, scalable, and maintainable tests that you and your team can trust.\nWhat Selenium Is and Is Not Good At Selenium is built to automate browsers, specifically human interaction with them. Things like navigating to pages, clicking on elements, typing text into input fields, etc.\nIt\u0026rsquo;s less ideal for checking lower-level functionality like HTTP status codes or HTTP headers. While you can use Selenium this way, it requires additional setup of a third-party tool (e.g., a proxy server like BrowserMob Proxy ), and it is a slippery slope since there are numerous edge cases to consider at this level.\nSelenium Highlights Selenium works on every major browser, in every major programming language, and on every major operating system. Each language binding and browser are actively being developed to stay current. Yes, even Internet Explorer (thanks to Jim Evans !). And WebDriver (the thing which drivers Selenium) has become a W3C specification .\nSelenium can be run on your local computer, on a remote server, on a set of servers (with Selenium Grid), or on a third-party cloud provider. As your test suite grows, your test runs will take longer to complete. To speed them up you will want to run them in parallel, which is where the benefit of having your own servers or using a cloud provider comes in \u0026ndash; that, and the ability to have numerous browser and operating system combinations to run your tests on.\nOne of the guiding philosophies of Selenium is to be able to write your tests once and run them across multiple browsers. While this is a rosy proposition, it\u0026rsquo;s not entirely accurate. There are some gotchas to watch out for when you get into it. But don\u0026rsquo;t worry, We\u0026rsquo;ll step through these in detail throughout the book.\n","permalink":"https://codingactions.com/selenium-with-nodejs-part-1-selenium-in-a-nutshell/","tags":["Selenium","Javascript","Node.js"],"title":"Selenium webdriver nodejs: Selenium In A Nutshell"},{"categories":["Automated Testing"],"contents":"This blog series steps through the process of writing Selenium WebDriver UI tests in Node.js from the first line of code through to running tests at scale in the cloud.\nSelenium In A Nutshell Defining A Test Strategy Picking A Language A Programming Primer Anatomy Of A Good Acceptance Test Writing Your First Test Verifying Your Locators Writing Re-usable Test Code Writing Really Re-usable Test Code Prepping For Use Running A Different Browser Locally Running Browsers In The Cloud Speeding Up Your Test Runs Flexible Test Execution Automating Your Test Runs ","permalink":"https://codingactions.com/selenium-with-nodejs-toc/","tags":["Selenium","Javascript","Node.js"],"title":"Selenium webdriver nodejs: Table of Contents"},{"categories":null,"contents":"Coding Actions is a technical blog for Developers, Testers, SDET (Software Development Engineer in Test), DevOps and Content Creators to understand Coding, Testing, RPA, and DevOps concepts in a simplified way.\nWe mainly focus in these areas:\nProgramming Languages tutorials (mainly JavaScript, C#, Java, html and CSS) Design paterns tutorials such as AWS, Kafka, Elastic Automated Testing SEO (Search Engine Optimization) RPA (Robotic Automatisation Process) Tools Please do not hesitate to contact us should you have any queries or require further information.\n","permalink":"https://codingactions.com/about-us/","tags":null,"title":"About Coding Actions"},{"categories":null,"contents":"If you require any more information or have any questions about our site’s disclaimer, please feel free to contact us by email at contact.codingactions@gmail.com .\nDisclaimers for CodingActions All the information on this website – https://codingactions.com/ – is published in good faith and for general information purpose only. CodingActions does not make any warranties about the completeness, reliability and accuracy of this information. Any action you take upon the information you find on this website (CodingActions), is strictly at your own risk. CodingActions will not be liable for any losses and/or damages in connection with the use of our website.\nFrom our website, you can visit other websites by following hyperlinks to such external sites. While we strive to provide only quality links to useful and ethical websites, we have no control over the content and nature of these sites. These links to other websites do not imply a recommendation for all the content found on these sites. Site owners and content may change without notice and may occur before we have the opportunity to remove a link which may have gone \u0026lsquo;bad\u0026rsquo;.\nPlease be also aware that when you leave our website, other sites may have different privacy policies and terms which are beyond our control. Please be sure to check the Privacy Policies of these sites as well as their \u0026ldquo;Terms of Service\u0026rdquo; before engaging in any business or uploading any information.\nConsent By using our website, you hereby consent to our disclaimer and agree to its terms.\nUpdate Should we update, amend or make any changes to this document, those changes will be prominently posted here.\n","permalink":"https://codingactions.com/disclaimer/","tags":null,"title":"Disclaimer"},{"categories":null,"contents":"At CodingActions, accessible from https://codingactions.com/ , one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by CodingActions and how we use it.\nIf you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us.\nThis Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in CodingActions. This policy is not applicable to any information collected offline or via channels other than this website.\nConsent By using our website, you hereby consent to our Privacy Policy and agree to its terms.\nInformation we collect The personal information that you are asked to provide, and the reasons why you are asked to provide it, will be made clear to you at the point we ask you to provide your personal information.\nIf you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide.\nWhen you register for an Account, we may ask for your contact information, including items such as name, company name, address, email address, and telephone number.\nHow we use your information We use the information we collect in various ways, including to:\nProvide, operate, and maintain our website Improve, personalize, and expand our website Understand and analyze how you use our website Develop new products, services, features, and functionality Communicate with you, either directly or through one of our partners, including for customer service, to provide you with updates and other information relating to the website, and for marketing and promotional purposes Send you emails Find and prevent fraud Log Files CodingActions follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users’ movement on the website, and gathering demographic information.\nCookies and Web Beacons Like any other website, CodingActions uses \u0026lsquo;cookies\u0026rsquo;. These cookies are used to store information including visitors\u0026rsquo; preferences, and the pages on the website that the visitor accessed or visited. The information is used to optimize the users\u0026rsquo; experience by customizing our web page content based on visitors\u0026rsquo; browser type and/or other information.\nChildren\u0026rsquo;s Information Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity.\nCodingActions does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately and we will do our best efforts to promptly remove such information from our records.\n","permalink":"https://codingactions.com/privacy-policy/","tags":null,"title":"Privacy Policy"},{"categories":null,"contents":"","permalink":"https://codingactions.com/search/","tags":null,"title":"search resultats"},{"categories":null,"contents":"Welcome to CodingActions!\nThese terms and conditions outline the rules and regulations for the use of CodingActions\u0026rsquo;s Website, located at https://codingactions.com/ .\nBy accessing this website we assume you accept these terms and conditions. Do not continue to use CodingActions if you do not agree to take all of the terms and conditions stated on this page.\nThe following terminology applies to these Terms and Conditions, Privacy Statement and Disclaimer Notice and all Agreements: \u0026ldquo;Client\u0026rdquo;, \u0026ldquo;You\u0026rdquo; and \u0026ldquo;Your\u0026rdquo; refers to you, the person log on this website and compliant to the Company\u0026rsquo;s terms and conditions. \u0026ldquo;The Company\u0026rdquo;, \u0026ldquo;Ourselves\u0026rdquo;, \u0026ldquo;We\u0026rdquo;, \u0026ldquo;Our\u0026rdquo; and \u0026ldquo;Us\u0026rdquo;, refers to our Company. \u0026ldquo;Party\u0026rdquo;, \u0026ldquo;Parties\u0026rdquo;, or \u0026ldquo;Us\u0026rdquo;, refers to both the Client and ourselves. All terms refer to the offer, acceptance and consideration of payment necessary to undertake the process of our assistance to the Client in the most appropriate manner for the express purpose of meeting the Client\u0026rsquo;s needs in respect of provision of the Company\u0026rsquo;s stated services.\nAny use of the above terminology or other words in the singular, plural, capitalization and/or he/she or they, are taken as interchangeable and therefore as referring to same.\nCookies We employ the use of cookies. By accessing CodingActions, you agreed to use cookies in agreement with the CodingActions\u0026rsquo;s Privacy Policy.\nMost interactive websites use cookies to let us retrieve the user\u0026rsquo;s details for each visit. Cookies are used by our website to enable the functionality of certain areas to make it easier for people visiting our website. Some of our affiliate/advertising partners may also use cookies.\nLicense The content on our website is for informational purposes. You can use the content for your own benefit. The content on our website draws knowledge from two websites namely StackOverflow and StackExchange.\nHowever, We don\u0026rsquo;t blatantly copy content from these two websites.\nAll intellectual property rights are reserved. You may access this from CodingActions for your own personal use subjected to restrictions set in these terms and conditions.\nThis Agreement shall begin on the date hereof.\nParts of this website offer an opportunity for users to post and exchange opinions and information in certain areas of the website. CodingActions does not filter, edit, publish or review Comments prior to their presence on the website. Comments do not reflect the views and opinions of CodingActions, its agents and/or affiliates. Comments reflect the views and opinions of the person who post their views and opinions. To the extent permitted by applicable laws, CodingActions shall not be liable for the Comments or for any liability, damages or expenses caused and/or suffered as a result of any use of and/or posting of and/or appearance of the Comments on this website.\nCodingActions reserves the right to monitor all Comments and to remove any Comments which can be considered inappropriate, offensive or causes breach of these Terms and Conditions.\nYou warrant and represent that:\nYou are entitled to post the Comments on our website and have all necessary licenses and consents to do so; The Comments do not invade any intellectual property right, including without limitation copyright, patent or trademark of any third party; The Comments do not contain any defamatory, libelous, offensive, indecent or otherwise unlawful material which is an invasion of privacy The Comments will not be used to solicit or promote business or custom or present commercial activities or unlawful activity. You hereby grant CodingActions a non-exclusive license to use, reproduce, edit and authorize others to use, reproduce and edit any of your Comments in any and all forms, formats or media.\niFrames Without prior approval and written permission, you may not create frames around our Webpages that alter in any way the visual presentation or appearance of our Website.\nYour Privacy Please read Privacy Policy\nDisclaimer As long as the website and the information and services on the website are provided free of charge, we will not be liable for any loss or damage of any nature.\n","permalink":"https://codingactions.com/terms-conditions/","tags":null,"title":"Terms \u0026 Condition"},{"categories":null,"contents":"","permalink":"https://codingactions.com/posts/automated-testing/k6/001_performance-testing-k6/","tags":null,"title":""},{"categories":null,"contents":"Whether you have a question about posts, trials, need assistance, or anything else, our team is ready to answer all your questions.\nWe\u0026rsquo;d be happy to help you !\nName: E-Mail: Subject: Message: Send Message ","permalink":"https://codingactions.com/contact-us/","tags":null,"title":"Contact Us"},{"categories":null,"contents":"Thanks for contacting us, we will reply to you as soon as possible.\n","permalink":"https://codingactions.com/thanks-for-contacting-us/","tags":null,"title":"Thank you for contacting us!"}]